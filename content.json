{"meta":{"title":"eyes487的博客","subtitle":null,"description":"knowledge point record","author":"xm","url":"http://blog.eyes487.top"},"pages":[{"title":"categories","date":"2019-10-10T12:28:01.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"categories/index.html","permalink":"http://blog.eyes487.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue源码解析（三）：数据响应式","slug":"vue-sourcec-analyse-03","date":"2020-01-28T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2020/01/28/vue-sourcec-analyse-03.html","link":"","permalink":"http://blog.eyes487.top/2020/01/28/vue-sourcec-analyse-03.html","excerpt":"","text":"Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。 之前写过一篇文章《实现MVVM原理》,今天从源码的角度了解一下数据响应式是如何实现的。在上一篇文章 initState 处就是做数据响应式的，今天就从这里开始。 1.initState()core/instance/state.js中 1234567891011121314151617 export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 属性初始化 if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) // 数据响应式====&gt;从这进入 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 在里面做了一系列数据的初始化，包括props，methods，但是最重要的是data一般用户都会定义data，然后对data做数据响应式，就进入到 initData 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function initData (vm: Component) &#123; // 把数据从options中取出来 let data = vm.$options.data //对data的定义可是函数也可以是对象 data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance // 代理这些数据到实例上，通过实例就可以直接访问到数据 const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] //这上面做的是一些判重 if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 主要代码--代理 proxy(vm, `_data`, key) &#125; &#125; // observe data // 响应式操作 observe(data, true /* asRootData */)&#125; 这个文件中就是获取data，设置代理，启动响应式observe 2.Observer所有数据响应式的代码都在 observer 文件夹下,MVVM框架最重要的就是数据响应式了 1234567891011121314151617181920212223export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; // 观察者，已经存在直接返回，否则创建新的实例 let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 这个方法，主要是判断是否存在(ob属性），如果存在就直接返回，如果不存在就通过new Observer创建一个，下面看看Observer主要做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 每一个响应式对象都会有一个obexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value // 为什么在Observer里面声明dep？ // object里面新增或者删除属性 // array中有变更方法 this.dep = new Dep() this.vmCount = 0 // 设置一个__ob__属性引用当前Observer实例 def(value, '__ob__', this) // 判断类型 if (Array.isArray(value)) &#123; // 替换数组对象原型 if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; // 如果数组里面元素是对象还需要做响应化处理 this.observeArray(value) &#125; else &#123; // 对象直接处理 this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 在Observer构造函数中， 设置_ob_属性， 判断类型是数组还是对象，对象就直接处理，如果是数组就替换数组原型，能改变数组值的只有7个数组方法 ‘push’,’pop’,’shift’,’unshift’,’splice’,’sort’,’reverse’ 然后遍历对象对每个key值执行 defineReactive 方法 其次，还额外创建了一个Dep，这是用来管理$set方法增加的属性，通知页面更新，或者数组删除和新增了元素 下面看看defineReacive里做了什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; // 和key一一对应 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; // 属性拦截，只要是对象类型均会返回childOb let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; // 获取key对应的值 const value = getter ? getter.call(obj) : val // 如果存在依赖 if (Dep.target) &#123; // 收集依赖 dep.depend() // 如果存在子ob，子ob也收集这个依赖 if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; // 如果新值是对象，也要做响应化 childOb = !shallow &amp;&amp; observe(newVal) // 通知更新 dep.notify() &#125; &#125;)&#125; 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://blog.eyes487.top/tags/MVVM/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（二）：new Vue() 初始化流程","slug":"vue-sourcec-analyse-02","date":"2020-01-27T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2020/01/27/vue-sourcec-analyse-02.html","link":"","permalink":"http://blog.eyes487.top/2020/01/27/vue-sourcec-analyse-02.html","excerpt":"","text":"上一篇文章已经说到如何来解读框架源码，这篇文章就通过走一遍new Vue()创建一个实例所要经过的过程来解读其中的代码所发挥的作用。下面不重要的一些代码都会通过//...省略掉 1.new Vue()123456const app = new Vue(&#123; el: '#demo', data:&#123; msg:'hello world' &#125; &#125;) 通过断点，我们会进入instance/index.js中 123456function Vue (options) &#123; //... // 初始化 this._init(options)&#125;initMixin(Vue) // 通过该方法给Vue添加_init方法 很明显，在Vue构造函数中，只执行了this._init初始化，进入_init函数，就进入到initMixin中，可见，_init是通过下面的initMixin方法添加在函数原型上的。 2.initMixin1234567891011121314151617181920212223242526272829303132333435363738394041424344export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag // a flag to avoid this being observed vm._isVue = true // 1.合并选项,默认选项和用户传进来的选项，比如一些全局组件会被合并 // merge options if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ //2. 定义了vm._renderProxy ，后期为render做准备的，作用是在render中将this指向vm._renderProxy if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self // 3. vm._self = vm initLifecycle(vm) // $parent, $root, $children, $refs initEvents(vm) // 对父组件传入事件添加监听 initRender(vm) // 声明$slots,$createElement() callHook(vm, 'beforeCreate') // 调用beforeCreate钩子 initInjections(vm) // 注入数据 initState(vm) // 重要：数据初始化，响应式 initProvide(vm) // 提供数据 callHook(vm, 'created') if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 这个方法主要是为Vue原型上添加_init方法，而在_init方法中做的几件事情使我们要关注的。 mergeOptions 合并选项 定义了vm._renderProxy 其他方法(重要)，下面具体介绍 2.1 initLifecycle1234567891011121314151617181920212223242526export function initLifecycle (vm: Component) &#123; const options = vm.$options // locate first non-abstract parent //建立所有组件的父子关系 let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 在这里是一些跟声明周期相关变量的初始化，比如: 父亲($parent),祖先($root),孩子($children),引用($refs) 2.2 initEvents12345678910export function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events //将父组件模板中注册的事件放到当前组件实例的listeners里面 const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 处理父组件传入的事件和回调，事件是谁派发谁监听 2.3 initRender12345678910111213141516171819202122232425262728293031export function initRender (vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // 给编译器生成渲染函数使用的，内部使用 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // render(h) 此处的$createElement就是h // 用户render使用的 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true) &#125; else &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true) &#125;&#125; 这个函数中，做的主要的两件事情就是声明 $slot ,$createElement 2.4 callHook123456789101112131415export function callHook (vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] const info = `$&#123;hook&#125; hook` if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info) &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit('hook:' + hook) &#125; popTarget()&#125; 调用钩子函数，这里调用了beforeCreate，之前声明的变量，此时都可以调用了，下面会用此方法调用created 2.5 initInjections/initProvide先理解Vue2.0中的Provide/inject 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 1234567891011121314151617181920212223242526//将$options里的provide赋值到当前实例上export function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === 'function' ? provide.call(vm) : provide &#125;&#125;export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) //这个方法主要就是对inject属性中的各个key进行遍历，然后沿着父组件链一直向上查找provide中和inject对应的属性，直到查找到根组件或者找到为止，然后返回结果 if (result) &#123; //对result的一些处理，比如在非生产环境会将result里的值定义成相应式的。 toggleObserving(false) Object.keys(result).forEach(key =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; //... &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125; 注入数据和提供数据，注入数据之后要判重，或者做一些其他的操作，提供给其他组件，所以注入数据在提供数据之前 2.6 initState1234567891011121314151617export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 属性初始化 if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) // 数据响应式 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 数据响应式，这是很重要的一部分，先大致看看做了什么操作，详细了解 2.7 $mount下面就执行挂载方法了Vue源码解析（三）：数据响应式 123if (vm.$options.el) &#123; vm.$mount(vm.$options.el)&#125; 之前提到过，$mount是在entry-runtime-with-compiler.js中做了一些额外的判断，但主要的实现方法是在runtime/index.js中 123456789// 实现$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined // 初始化，将首次渲染结果替换el return mountComponent(this, el, hydrating)&#125; 然后调用mountComponent()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') &#123; //... &#125; &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; //... &#125; &#125; else &#123; // 用户$mount()时，定义updateComponent updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) //会通过new Watcher中的get方法调用 &#125; &#125; // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; vm._update 会调用 vm.render()方法,先执行render方法返回vnode，在通过update转换为真实dom 1234567891011121314151617181920212223242526272829303132333435363738394041424344Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options //从vm.options中拿到的变量来自于 instance/index.js中给实例添加的属性,通过调用下面这些方法 //stateMixin(Vue) // $set,$delete,$watch // eventsMixin(Vue) // $emit,$on,$off,$once // lifecycleMixin(Vue) // _update(),$forceUpdate(),$destroy() // renderMixin(Vue) // _render(), $nextTick if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; currentRenderingInstance = vm // vm.$createElement就是h vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; //... &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; //... &#125; // set parent vnode.parent = _parentVnode return vnode &#125;&#125; 12345678910111213141516171819202122232425262728Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) //这句执行为页面就变为真实dom了，页面数据就发生变化了 &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) //diff算法就是在这里发生的，之后会有文章仔细说明 &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; &#125; 3.总结梳理一下创建实例的整个流程 new Vue(): 调用init this._init(): 初始化各种属性 $mount: 调用mountComponent mountComponent: 声明updateComponent、创建Watcher _render(): 获取虚拟dom _update(): 把虚拟dom转换为真实dom 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（一）：如何解读源码","slug":"vue-sourcec-analyse-01","date":"2020-01-26T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2020/01/26/vue-sourcec-analyse-01.html","link":"","permalink":"http://blog.eyes487.top/2020/01/26/vue-sourcec-analyse-01.html","excerpt":"","text":"以前听人说解读一个框架的源码，最好的方法就是自己写一个小实例，通过浏览器断点（f10，应该大家都知道的）看运行这个实例执行了哪些步骤，想知道某个方法是如何实现的，就执行某个方法，通过断点查看它到底做了些什么。这个方法是很有用的，今天就通过此方法向大家介绍解读源码的步骤。 1.准备工作1.1 克隆源码123地址： https://github.com/vuejs/vue通过命令： git clone https://github.com/vuejs/vue.git当前版本： 2.6.10 1.2 安装依赖12安装依赖： cd vue &amp;&amp; npm install 打包工具rollup： npm install rollup -g (如果以前没有安装) 1.3 修改dev脚本在package.json中 在scripts中找到dev，添加 –sourcemap，如下 123\"scripts\": &#123; \"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\", \"dev:cjs\": \"rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev\", 文件打包之后都是一个压缩文件，通过sourcemap可以定位源文件 1.4 执行1npm run dev 打包之后，会在dist文件夹下新增一个vue.js.map文件，vue.js也会被修改这样准备工作就算完成了 2.目录结构下面是一些核心文件，以及他们的用途 123456dist- - -发布目录，所有输出文件都在里面 （打包出的文件，关键字含义） runtime- - -仅包含运行时，不包含编译器 common- - -cjs规范，用于webpack1 esm- - -ES模块，用于webpack2+ umd(什么都不带的)- - -兼容cjs和amd，一般用于浏览器 3.查找入口文件3.1 在package.json中，dev命令中1\"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\", 代码里可以发现两个关键点 scripts/config.js和web-full-dev,所以去到config.js可以发现 123456789// Runtime+compiler development build (Browser) 'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), //&lt;=====这个文件 dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, 3.2 web/entry-runtime-with-compiler.js这个文件位于 src/platforms/web/下面 如果遇到/* istanbul ignore if */,这个代码不重要，甚至可以直接删掉，只用于调试阶段，下面我贴的源码就直接删掉以节约空间了,只会贴出主要代码,重要部分都会写上注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import Vue from './runtime/index'...// 保存原来的$mountconst mount = Vue.prototype.$mount// 覆盖默认$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) // 解析option const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template // 模板解析 if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template) &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; // 如果存在模板，执行编译 if (template) &#123; // 编译得到渲染函数 const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns &#125; &#125; // 执行挂载 return mount.call(this, el, hydrating)&#125;function getOuterHTML (el: Element): string &#123; if (el.outerHTML) &#123; return el.outerHTML &#125; else &#123; const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML &#125;&#125;Vue.compile = compileToFunctions 从代码可以看出，new Vue的时候，优先级是render，template，el，最终都是得到render函数 这个文件的主要作用：覆盖$mount,执行模板解析和编译工作 这个文件发现Vue引入自runtime/index 3.3 runtime/index.js123456789101112131415161718import Vue from 'core/index'import &#123; extend, noop &#125; from 'shared/util'import &#123; mountComponent &#125; from 'core/instance/lifecycle'// install platform patch function// 指定补丁方法：传入虚拟dom转换为真实domVue.prototype.__patch__ = inBrowser ? patch : noop// public mount method// 实现$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined // 初始化，将首次渲染结果替换el return mountComponent(this, el, hydrating)&#125; 这个文件主要定义$mount方法和其他额外配置 这个文件发现Vue引入自core/index 3.4 core/index.js12345import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'// 定义全局apiinitGlobalAPI(Vue) 这个文件主要定义全局api，在Vue山挂在一些其他方法 这个文件发现Vue引入自instance/index 3.5 instance/index.js123456789101112131415161718192021222324import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'// 构造函数function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; // 初始化 this._init(options)&#125;initMixin(Vue) // 通过该方法给Vue添加_init方法stateMixin(Vue) // $set,$delete,$watcheventsMixin(Vue) // $emit,$on,$off,$oncelifecycleMixin(Vue) // _update(),$forceUpdate(),$destroy()renderMixin(Vue) // _render(), $nextTickexport default Vue 终于在这个文件中找到了Vue构造函数，里面只执行了init方法，init方法是通过initMixin()给Vue添加_init方法 同时，也添加了很多实例方法 在init.js文件中initMixin()方法 12345678910// 主要代码 vm._self = vm initLifecycle(vm) // $parent, $root, $children, $refs initEvents(vm) // 对父组件传入事件添加监听 initRender(vm) // 声明$slots,$createElement() callHook(vm, 'beforeCreate') // 调用beforeCreate钩子 initInjections(vm) // 注入数据 initState(vm) // 重要：数据初始化，响应式 initProvide(vm) // 提供数据 callHook(vm, 'created') 这次主要是寻找入口文件，所以没有对里面的方法去进行深究，之后会有专门的文章对他们进行解读 4. 实例在examples中，建一个test.html 12345678910111213141516&lt;head&gt; &lt;script src=\"../../dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;div id=\"demo\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script&gt; // 创建实例 const app = new Vue(&#123; el: '#demo', // template: '&lt;div&gt;template&lt;/div&gt;', // render(h)&#123;return h('div','render')&#125;, data:&#123;msg:'hello world!!!!!'&#125; &#125;)&lt;/script&gt; 就可以通过断点在浏览器中看到执行的过程了，如果想看某个方法具体执行了什么，就进入该方法查看，从开始到浏览器渲染完成，就是整个渲染流程所执行的过程。 Vue源码解读方法，差不多就是这样了，之后会有具体文章分析Vue的重要实现过程。 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"记一次性能优化，从六七秒优化到1.35s","slug":"one-time-optimization","date":"2019-12-07T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/12/07/one-time-optimization.html","link":"","permalink":"http://blog.eyes487.top/2019/12/07/one-time-optimization.html","excerpt":"","text":"这是在还没毕业做的一个项目，一直放在之前的服务器上，不久之前服务器到期了。趁着双十一的机会，优惠很大就又买了一个，把项目迁移到新的服务器上。首页加载的速度有六七秒左右，以前也优化过一些，但以前技术有限，就没怎么管它了。这次趁着换新服务器，就想着来优化一下网站。网速、电脑响应速度等 都会对页面加载速度有影响，基本可以稳定在 1秒多(未使用CDN)，先上网站地址 花间道,下面从我所用到的优化方法介绍。 1. 减少http请求数众所周知，减少 http 请求数是缩短页面加载时间最有效的方法 资源压缩和合并，尽可能的将外部的脚本、样式进行合并，多个合为一个。 使用 CSS Sprites，通过背景定位获取具体图像 合理的设置http缓存 1.1 合并压缩合并压缩的构建工具有，gulp，webpack，grunt等，我当时使用的是gulp，gulp不能处理ES6代码，所以还是得用webpack，是否要合并代码还是要具体看自己的需求。这个就自己去查看webpack了。 下面是使用gulp处理less转化为css，并且会压缩代码 123456gulp.task('less',function () &#123; gulp.src('public/less/*.less') .pipe(gulp_less()) .pipe(gulp_minify_css()) .pipe(gulp.dest('public/stylesheets'))&#125;); 1.2 CSS Sprites推荐自动生成雪碧图的工具: https://www.toptal.com/developers/css/sprite-generatorwebpack 中有一款生成雪碧图的插件，webpack-spritesmith,会自动帮你生成调用雪碧图的css样式 1.3 http缓存http缓存分为 强制缓存 和 协商缓存 强制缓存在响应头中会有（Expires/Cache-Control）,Expires是1.0的东西，在http 1.1都是用Cache-Control代替了 Cache-Controlprivate 客户端可以缓存public 客户端和代理服务器都可以缓存max-age=60 缓存内容将在60秒后失效no-cache 需要使用对比缓存验证数据,强制向源服务器再次验证. 禁用强制缓存no-store 所有内容都不会缓存，强制缓存和对比缓存都不会触发。 12345678910111213141516171819202122232425262728let http = require('http');let url = require('url');let path = require('path');let fs = require('fs');let mime = require('mime');http.createServer(function (req, res) &#123; let &#123; pathname &#125; = url.parse(req.url, true); let filepath = path.join(__dirname, pathname); console.log(filepath); fs.stat(filepath, (err, stat) =&gt; &#123; if (err) &#123; return sendError(req, res); &#125; else &#123; send(req, res, filepath); &#125; &#125;);&#125;).listen(8080);function sendError(req, res) &#123; res.end('Not Found');&#125;function send(req, res, filepath) &#123; res.setHeader('Content-Type', mime.getType(filepath)); //expires指定了此缓存的过期时间，此响应头是1.0定义的，在1.1里面已经不再使用了 res.setHeader('Expires', new Date(Date.now() + 30 * 1000).toUTCString()); res.setHeader('Cache-Control', 'max-age=30'); //设置缓存时间为30s fs.createReadStream(filepath).pipe(res);&#125; 协商缓存使用 Etag/If-None-Match , Last-Modified/If-Modify-Since 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 使用 Last-Modified/If-Modify-Since方法 1234567891011121314151617181920212223242526272829303132http.createServer(function (req, res) &#123; let &#123;pathname&#125; = url.parse(req.url); let filepath = path.join(__dirname,pathname); console.log(filepath); fs.stat(filepath,function (err, stat) &#123; if (err) &#123; return sendError(req,res) &#125; else &#123; // 再次请求的时候会问服务器自从上次修改之后有没有改过 let ifModifiedSince = req.headers['if-modified-since']; let LastModified = stat.ctime.toGMTString(); if (ifModifiedSince == LastModified) &#123; res.writeHead('304'); res.end('') &#125; else &#123; return send(req,res,filepath,stat) &#125; &#125; &#125;)&#125;).listen(8080)function send(req,res,filepath,stat) &#123; res.setHeader('Content-Type', mime.getType(filepath)); // 发给客户端之后，客户端会把此时间保存下来，下次再获取此资源的时候会把这个时间再发给服务器 res.setHeader('Last-Modified', stat.ctime.toGMTString()); fs.createReadStream(filepath).pipe(res)&#125;function sendError(req,res) &#123; res.end('Not Found')&#125; 使用 Etag/If-None-Match方法, Etag 的优先级高于 Last-Modified 12 2.图片优化我的网站访问起来太慢，最主要的原因还是由于使用了大量图片，除了压缩图片，上面说了可以使用雪碧图来减少图片请求，还可以使用字体图标代替一些小图片，其次使用webp格式，可以减少图片的大小。 使用图片的时候，尽量指定图片大小，不要缩放图片,如果网页中需要什么尺寸的图片，就设计什么尺寸的图片。因为浏览器下载到原始图片之后，如果尺寸与目标尺寸不合，浏览器就会去处理图片(拉伸或者缩小)，造成浏览器负担。 2.1 使用字体图标我使用的是fontawesome,但是文件体积有点大，我请求 fontawesome-webfont.woff2?v=4.7.0这个文件的时候，要花1秒多，里面有很多的图标其实我并没有用到。推荐一个网站，http://fontello.com/,可以到里面选择自己需要的图标，然后下载下来，替换掉fontawesome-webfont.woff 这个文件。当然也可以用 IconFont，只是我之前是fontawesome，我懒得换了。 2.2 使用webp格式推荐一个网址，可以转换图片格式为webp，https://www.upyun.com/webp webp使用方法 12345//html中&lt;picture&gt; &lt;source type=\"image/webp\" srcset=\"123.webp\"&gt; &gt; &lt;img src=\"123.jpg\" alt=\"\"&gt;&lt;/picture&gt; 12345678910111213141516171819//首先判断浏览器是否支持webp格式，给文档加上data-webp属性function isSupportWebp() &#123; var flag = '0'; var canvasEL = document.createElement('canvas'); var docEl = document.documentElement || document.getElementsByTagName('html')[0]; if (canvasEL.getContext &amp;&amp; canvasEL.getContext('2d')) &#123; flag = canvasEL.toDataURL('image/webp').indexOf('image/webp') &gt; -1 ? '1': '0' &#125;; docEl.setAttribute('data-webp', flag); return flag&#125;;// 然后在背景图片中引用,css文件中[data-webp=\"0\"] div&#123; background: ur(\"./123.jpg\")&#125;[data-webp=\"1\"] div&#123; background: ur(\"./123.webp\")&#125; 推荐谷歌的性能检测工具—PageSpeed,在谷歌网上商店可以找到，里面会帮你提供有哪些需要改进的地方，在优化图片中会帮你把图片压缩一下，可以直接下载下来使用 3. Gzip传输压缩在服务器开启Gzip压缩，可以将文件在传输的时候体积压缩70% 左右，所有浏览器都支持gzip解压，都是自动的。 不要对图片进行压缩，首先http压缩是需要成本的，其次，采用HTTP压缩已经被过压缩的东西并不能使它更小。图片压缩不仅浪费了CPU，还有可能增大图片的体积。 我使用的是 nginx,通过在 nginx.config 配置下面代码 123456gzip on; //打开gzipgzip_min_length 1k; //当返回内容大于此值时才会使用gzip进行压缩,以K为单位,当值为0时，所有页面都进行压缩。#gzip_http_version 1.0; //用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在http/1.0的协议下不开启gzip压缩。gzip_comp_level 2; //设置gzip压缩级别，级别越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; //设置需要压缩的MIME类型,如果不在设置类型范围内的请求不进行压缩gzip_vary off; //是否启用应答头\"Vary: Accept-Encoding\" 设置成功之后，请求的响应头中会带有gzip字段 4. CDN加速CDN加速意思就是在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问。我们是不可能自己搭建CDN的，所以只有从阿里云，腾讯云之类的购买。因为我暂时不需要，所以就没有使用。(￣ˇ￣) 5. 代码优化 css应该放在页面首部，在页面生成Dom tree的时候，就可以同时渲染页面，不会发生闪屏，白屏和布局混乱。 js是会阻塞页面加载的，所以js可以放在页面尾部，或者使用defer等延迟加载。 使用渐进式加载图片，先用分辨率的图片，等空闲时间在切换高清图片。 减少操作dom的次数，把多次操作变为一次操作，比如脱离文档流，隐藏元素等 重排一定会重绘，更应该减少重排的发生 下面是我用PageSpeed测试的结果，查询数据的接口，我认为没有做缓存的必要，所以就没有做缓存 参考链接： 《网站性能优化实战——从12.67s到1.06s的故事》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"js 性能优化","slug":"js-性能优化","permalink":"http://blog.eyes487.top/tags/js-性能优化/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"React Native 开发中所遇到的问题","slug":"problem-of-react-native","date":"2019-10-21T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/10/21/problem-of-react-native.html","link":"","permalink":"http://blog.eyes487.top/2019/10/21/problem-of-react-native.html","excerpt":"","text":"入坑React Native半年多了，平时也会遇到一些问题，但是解决之后，下次遇到可能就记不得，现在已经想不起之前遇到的一些问题了，所以想记录下来，方便以后可以回顾，如果有遇到类似问题的人，也可以有一个参考，这篇博客会不定期累加问题。 1.Task :app:compileDebugJavaWithJavac FAILED 一般导致这种错误的情况会有很多，大部分时候，我在发生这种错误时，在控制台启动项目的时候会报出错误的文件，或者执行gradlew compileDebugJavaWithJavac 命令也可以看到具体的错误信息,利用Android Studio查看错误的文件，可以看到具体是哪行发生了错误。 一般我遇到的错误，大部分是引用错误，在升级了AndroidX之后，可是之前引用的一些包会不兼容，需要把android引用改为androidx的。 这些错误一般都是由于引用的第三方库里发生的错误，也就是node_modules中的文件，每次npm之后，node_modules中的文件就会更新，所以每次去改就很麻烦。可以把第三方库fork到自己的git仓库中，更改代码，package.json中的地址就引用自己Git仓库中的地址。 使用一些第三方库的时候，有时因为第三方库并不是一直在维护的，有可能集成进去，会有 sdk 兼容问题，所以要把sdk版本改为和自己项目中的一致，也可以fork到自己的仓库中，避免每次修改。 2.react-native-camera 集成问题实现扫码安装react-native-camera之后，会出现错误，我通过这个找到了解决办法。(PS: 最好从官方文档看教程，我之前就是在网上搜的教程，但是已经过时了，这样就浪费时间找问题出在哪，网上的教程作为一个参考点就行)但是最后这个库实现的扫码，速度没有达到我们的要求(正常手机扫码速度还可以，但是我们要在性能很差的平板上快速扫码就有点难度了)，所以放弃了这种方式，最后使用PDA扫码和集成红外摄像头扫码(通过使用java代码,以原生的方式实现，辛亏有大佬帮忙ヽ(○^㉨^)ﾉ♪) 3.react-native-ble-manager 连接蓝牙之前用的测试机是 Android5.1 的，能够正常扫描蓝牙，一直以为就这样就算正确使用这个插件连接蓝牙，但是之后用自己的手机运行app的时候，发现怎么都扫描不到蓝牙，从网上搜索得知，扫码蓝牙还需要开启位置权限 1234&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;uses-feature android:name=\"android.hardware.bluetooth_le\" android:required=\"true\"/&gt; 需要加入这些权限，但是我查看自己的AndroidManifest.xml文件时，发现这些权限已经加上去了。原来，在Android6之后，权限不仅要在清单文件AndroidManifest.xml里面申请,还有单独调用api，去让用户选择是否同意你申请这个权限。 123456789101112131415161718192021222324252627282930313233343536373839_checkLocation =()=&gt;&#123; if(Platform.OS === 'ios')&#123; return false; &#125; const granted = PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION) granted.then((data) =&gt; &#123; console.log('data----', data) if (!data) &#123; this.requestLocationPermission() &#125; &#125;).catch((err) =&gt; &#123; console.log('err---------', err.toString()) &#125;) &#125; //申请地址权限 async requestLocationPermission() &#123; try &#123; const granted = await PermissionsAndroid.request( PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION, &#123; //第一次请求拒绝后提示用户你为什么要这个权限 'title': '是否允许地址查询权限', 'message': '此权限会造成系统异常，请允许', buttonNeutral: '等会再问我', buttonNegative: '不行', buttonPositive: '好吧', &#125; ) if (granted === PermissionsAndroid.RESULTS.GRANTED) &#123; console.log(\"你已获取了定位权限\") &#125; else &#123; console.log(\"获取定位权限失败,会造成系统异常\") &#125; &#125; catch (err) &#123; console.log(err.toString()) &#125; &#125; 所以可以通过以上代码，获取位置权限。 4.native-echarts 经常加载不出因为对echarts很熟悉，所以要在react-native绘制图表时，就选择了使用echarts封装的native-echarts，但是这个库已经很久不维护了，所以就fork到自己的git地址中，修改了一些地方引用。 但是使用这个图表，有时候会加载不出来，我在网上搜索也并没有搜到解决办法，网上只有说在Android中显示不出来,把tpl.html文件复制到android/app/src/main/assets文件夹下。我也在交流群中问过一些人，他们好像都没有遇到类似问题，这让我很费解，也许是因为我需要实时刷新的缘故，也就没有找到解决办法了。 native-echarts中使用echarts的办法是通过Webview中引用html文件实现的，我给webview加了startInLoadingState属性，可以查看加载状态，在我实时刷新的时候，刷新次数过多，状态会一直处于加载中，就加载不出来了，不清楚是不是由于性能消耗过多，暂时没有解决。 所以就换了一个图表库，react-native-charts-wrapper,这种图表库是基于原生的，所以性能提高了很多，图表能立马加载出来，但也有一定局限性，只有八种图表，配置项也没有echarts那么多。 要使用这个图表，需要配置一些东西，在android中配置项较少，就不说了，ios中的配置可以参考这里,但其中一些知识点已经过时不需要了，所以正确步骤还是需要参照官方文档,但是官方文档没有配图，所以不懂的地方可以参考上面这个参考，有图片引导，更加易懂一点。 (PS： Charts应该使用3.3.0版本，但是git官方地址已经更新超过这个版本了，所以下载的时候一定要注意版本一致，我就是因为下载了最新的版本，所以一致对不上。这时候就体现出仔细查看官方文档的好处了ヽ(○^㉨^)ﾉ♪) 5.ios出现 Build input file cannot be found: ‘/Users/mac/Library/Developer/Xcode/DerivedData/jty-ceemylpddhxuyyegcppypjhihevw/Build/Products/Debug-iphonesimulator/jty.app/PlugIns/jtyTests.xctest/jtyTests’ 解决方法：Xcode &gt; File &gt; Workspace Settings…orXcode &gt; File &gt; Project Settings… Shared Project Settings和Per-User Project Settings 中的Build System都从New Build System (默认) 改为Legacy nuild System 6. react-native 从0.57.8升级到0.59.10，在Android中运行，出现 Could not get unknown property ‘mergeResourcesProvider’ for object of type com.android.build.gradle.internal.api.ApplicationVariantImpl. 解决方法：/android/build.gradle 改为classpath ‘com.android.tools.build:gradle:3.3.0’/android/gradle/wrapper/grale-wrapper.properties 改为 distributionUrl=https://services.gradle.org/distributions/gradle-4.10.1-all.zip 运行有可能会出错，记得清理一下缓存 cd android &amp;&amp; gradlew clean 7 Android9.0 http无法访问网络问题先说前提背景，首次使用react-native 0.60.5版本建立项目，在手机上调试的时候没有问题，打包安装在手机上出现闪退。在Android studio中Logcat上看到闪退报错信息： 7.1 .com.facebook.react.common.JavascriptException: console.assert is not a function. (In ‘console.assert(null!=o,”‘this’ is expected an Event object, but got”,n)’, ‘console.assert’ is undefined), stack:o@112:173 w@112:1841 dispatchEvent@112:5597 value@111:6095 value@111:2835 value@44:1280 value@23:3518 &lt;unknown&gt;@23:822 value@23:2772 value@23:794 value@-1解决办法：参考的 这里 添加如下信息在 index.js中 123456789101112if (!__DEV__) &#123; global.console = &#123; info: () =&gt; &#123;&#125;, log: () =&gt; &#123;&#125;, assert: () =&gt; &#123;&#125;, warn: () =&gt; &#123;&#125;, debug: () =&gt; &#123;&#125;, error: () =&gt; &#123;&#125;, time: () =&gt; &#123;&#125;, timeEnd: () =&gt; &#123;&#125;, &#125;;&#125; 通过这些操作，app不闪退了，但是页面还是没有如期显示，是因为并没有访问到网络，没有拿到后台的数据， 7.2 在网上搜索了一下，发现是Android 9会出现这个问题，我在Android 8测试了一下，发现是的，不会出现这个问题。解决方法： APP改用 https 请求 targetSdkVersion 降到27以下 在 AndroidManifest.xml 文件的 application 加入：android:usesCleartextTraffic=&quot;true&quot; 我采用的是第三种方法 8. Attempt to invoke virtual method ‘android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)’ on a null object reference使用场景：react-native 0.57.8 Android 9我在页面中，使用TextInput放入表格中的每个单元格，就出现了这个问题，其他时候是没有出现这个问题的 解决方法： 在 android/src/main/res/values/styles.xml 插入这句 1&lt;item name=\"android:editTextBackground\"&gt;@android:color/transparent&lt;/item&gt; 参考地址","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"React native","slug":"React-native","permalink":"http://blog.eyes487.top/tags/React-native/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"理解浏览器和Node中的事件循环(EventLoop)","slug":"eventloop","date":"2019-10-20T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/10/20/eventloop.html","link":"","permalink":"http://blog.eyes487.top/2019/10/20/eventloop.html","excerpt":"","text":"看过很多类似文章之后，想总结了一下关键点记录下来，方便之后回顾。了解EventLoop可以用来分析一些异步次序的问题，同时还能了解一些浏览器和Node的内部机制。 1.浏览器中的EventLoop1.1 js引擎的事件循环机制 js是一门单线程、无阻塞的脚本语言。 执行js文件的时候，会按照从上到下的顺序，把其中的同步代码加入执行栈中，然后按照顺序执行执行栈中的代码。 执行异步代码的时候，他不会立即返回结果，会将这个异步事件挂着，当异步事件返回结果的时候，就会把这个事件加入事件队列 他不会立即执行，直到执行栈中的所有任务都执行完毕，主线程处于闲置状态的时候，主线程就会去查询事件队列是都有任务 有的话,就从中取出排在第一位的事件，把这个事件的回调函数加入执行栈，然后执行其中的代码 如此反复，就形成了无线的循环，这个过程就叫做 事件循环 1.2 事件队列事件队列也分为 宏任务（macrotask) 和 微任务（microtask） 常见属于宏任务的有： script(整体代码) setTimeout / setInterval 事件回调 XHR 回调 history.back 常见属于微任务的有： new Promise new MutaionObserver() Object.observe(废弃) 在执行栈为空的时候，主线程首先会查看微任务列表是否为空 先执行微任务，执行完毕，在执行宏任务 同一次事件循环，微任务总是比宏任务先执行。 运行宏任务的时候，可能又会产生微任务，在执行完毕这次宏任务，又会查询是否有微任务需要执行。 使用一张从网上寻找的图片表示 1.3 示例12345678910111213141516171819202122232425262728293031console.log(1);setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;);&#125;);new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(5)&#125;).then((data) =&gt; &#123; console.log(data); Promise.resolve().then(() =&gt; &#123; console.log(6) &#125;).then(() =&gt; &#123; console.log(7) setTimeout(() =&gt; &#123; console.log(8) &#125;, 0); &#125;);&#125;)setTimeout(() =&gt; &#123; console.log(9);&#125;)console.log(10); 正确的打印顺序是: 1234567891014105672398 分析，第一步： 先打印1 setTimeout加入事件队列（宏任务) 接着打印 4，promise的返回的回调加入事件队列（微任务） setTimeout加入事件队列（宏任务） 接着打印10 第二步： 微任务在宏任务之前执行，打印 5 此次微任务又产生了微任务，会在宏任务之前执行，接着打印 6 打印 7 把setTimeOut 加入事件队列(宏任务) 第三步： 此时，已经不存在微任务，按照顺序执行宏任务，打印2 执行时，又产生了一个微任务，只能先执行这个微任务，打印3 微任务执行完毕，按照顺序，执行宏任务，打印9 打印 8 所以，如果执行任务的时候不断的产生了微任务，那之后的宏任务就没办法执行了 2.Node中的EventLoopNode的异步语法比浏览器更复杂，它可以和内核对话，所以它使用了libuv库来实现EventLoop，这个库负责各种回调函数的执行时间。 2.1 Node中提供了四个定时器 setTimeout() setInterval() setImmediate() process.nextTick()上面两个语言标准，后两个是Node中独有的。看看几个定时器在Node中的运行顺序:123456789101112setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))();//node index.js//5//3//4//1//2 Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环,而本轮循环一定早于次轮循环执行。 所有同步任务执行完之后就是异步任务，process.nextTick是异步任务中最早执行的，如果想要异步任务尽快执行，就使用process.nextTick。而promise的回调函数会被添加于微任务队列，追加在process.nextTick之后，也存在于本轮循环，只有等本轮循环(当前队列)执行完之后，才会进入下一队列。 2.2 事件循环的六个阶段事件循环会按照顺序，反复地执行。每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。 2.2.1 timers这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。 2.2.2 I/O callbacks除了一下操作的回调函数，其他回调函数都在这个阶段执行 setTimeout()和setInterval()的回调函数 setImmediate()的回调函数 用于关闭请求的回调函数，比如socket.on(‘close’, …) 根据libuv的文档，一些应该在上轮循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。 2.2.3 idle, prepare该阶段只供 libuv 内部调用，这里可以忽略。 2.2.4 Poll这个阶段是轮询时间，用于等待还未返回的 I/O事件，比如服务器的回应、用户移动鼠标等等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。 2.2.5 check该阶段执行setImmediate()的回调函数。 2.2.6 close callbacks该阶段执行关闭请求的回调函数，比如socket.on(&#39;close&#39;, ...)。 2.3 示例来自官方文档的一个示例 1234567891011121314151617const fs = require('fs');const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile('test.js', () =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;); 分析：第一轮 没有到期的定时器 也没有刻意执行的 I/O 回调函数 内核读取文件 Poll阶段，等待内核读取文件的结果，不会操作100ms，在定时器到期之前就会得到结果 第二轮 没有到期的定时器 有刻意执行的回调函数，进入I/O callbacks阶段，这个回调函数需要200ms，在执行到一般的时候，100ms定时器到期，但是必须等到这个回调函数执行完，才会离开这个阶段 第三轮 有了到期的定时器，所以会在timers阶段执行定时器，输出结果大概200多毫秒 2.4 setTimeout 和 setImmediate由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。 12345setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));//结果不确定//1 2 或者 2 1 因为 setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行，进入事件循环，有可能到了1毫秒，有可能没有，这取决于系统当时的情况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。 但是，下面代码一定是2 1 123456const fs = require('fs');fs.readFile('test.js', () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); 代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。 Node中的事件循环参考《Node 定时器详解》《不要混淆nodejs和浏览器中的event loop》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Js","slug":"Js","permalink":"http://blog.eyes487.top/tags/Js/"},{"name":"Node","slug":"Node","permalink":"http://blog.eyes487.top/tags/Node/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"手写DOM-Diff算法","slug":"dom-diff-algorithnm","date":"2019-10-13T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/10/13/dom-diff-algorithnm.html","link":"","permalink":"http://blog.eyes487.top/2019/10/13/dom-diff-algorithnm.html","excerpt":"","text":"接触React已经两年多了,提起React，总是免不了要和Vue做一番对比，两个框架都使用了虚拟DOM。那今天就了解一下什么是虚拟DOM，虚拟DOM的实现和使用吧。 1.虚拟DOM1.1 什么是虚拟DOM Virtual DOM 也就是虚拟节点。它通过js的Object对象模拟真实的DOM节点，然后在通过特定的 render 方法将其渲染成真实的DOM。在更改元素的时候并不是修改真正的DOM，而是通过虚拟DOM进行Diff运算，得到最小的差异生成补丁（Patch）应用到真实DOM中。 1234567//createElemnt =&gt;( type, props, children)createElement('ul',&#123; class: 'list'&#125;,[ createElemnt('li', &#123;class: 'item'&#125;, ['React']), createElemnt('li', &#123;class: 'item'&#125;, ['Vue']), createElemnt('li', &#123;class: 'item'&#125;, ['Angular']) ]) 虚拟DOM就是通过上面这样一个方法，创建的一个js对象，如下： 1.2 创建虚拟DOM可以通过create-react-app快速构建一个项目下面我们就来实现这个createElement方法,创建一个element.js 和 index.js 1234567891011121314//element.jsclass Element&#123; constructor(type,props,children)&#123; this.type = type; this.props = props; this.children = children; &#125;&#125;function createElement(type,props,children)&#123; return new Element(type,props,children)&#125;export &#123;createElement&#125; 12345678910//index.jsimport &#123;createElement&#125; from './element';let virtualDom = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['ANgular']),])console.log(virtualDom) //===&gt;打印出虚拟DOM 如上图 图1 1.3 渲染真实DOM通过 render 方法将虚拟DOM转化为真实DOM ,在通过renderDOM把真实DOM元素插入页面中 1234567891011121314151617181920212223242526272829303132//element.js 在element.js中添加如下方法function setAttr(node,key,value)&#123; switch(key)&#123; case 'value': if(node.tagName.toUpperCase() === \"INPUT\" ||node.tagName.toUpperCase === \"TEXTAREA\")&#123; node.value = value; &#125;else&#123; node.setAttribute(key,value); &#125; break; case 'style': node.style.cssText = value;break; //可能还有其他情况... default: node.setAttribute(key,value); &#125;&#125;//render方法可以将v-dom转化为真实domfunction render(eleObj)&#123; let el = document.createElement(eleObj.type); for(let key in eleObj.props)&#123; setAttr(el,key,eleObj.props[key]); //设置属性的方法 &#125; eleObj.children.forEach(child=&gt;&#123; //遍历子节点，如果是虚拟dom继续渲染，否则代表是文本节点 child = (child instanceof Element)?render(child) : document.createTextNode(child); el.appendChild(child); //放入父节点 &#125;) return el;&#125;//把真实dom插入目标源function renderDom(el,target)&#123; target.appendChild(el);&#125;export &#123;createElement,render,renderDom&#125;; 12345678910111213//index.jsimport &#123;createElement,render,renderDom&#125; from './element';let virtualDom = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['ANgular']),])let el = render(virtualDom)console.log(virtualDom)console.log(el);renderDom(el,window.root) 这样界面上就生成了一个无序列表 2. DOM-Diff2.1 DOM-Diff的作用比较两个虚拟DOM的区别，根据两个虚拟DOM创建出补丁，描述改变的内容，将这个补丁用来更新DOM 2.2 DOM-Diff比较时遵循的原则 只会比较平级节点，不会跨级比较 比较平级节点时，如发现节点不存在，会将该节点及其子节点完全删掉，节点类型变了会直接生成新的节点 比较平级节点时，如果只是两个节点产生位置变化，那么会复用此节点，将两个节点交换位置即可，通过给同级列表元素添加key值实现 DOM-Diff遵循 树的先序深度优先遍历 2.3 实现Diff算法可以先定义一些规则: 当节点类型相同，比较属性是否相同，如果不同，产生一个补丁包 {type:’ATTRs’,attrs:{class: ‘xxx’}} 当新dom节点不存在的时候，直接删除，补丁包 {type: ‘REMOVE’,index: xxx} 当节点类型不相同，就替换节点 {type: ‘REPLACE’,newNode: xxx} 当只是文本变化，就变更文本 {type: ‘TEXT’, text: ‘xxxx’}… 创建一个diff.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//diff.jsconst ATTRS = 'ATTRS';const TEXT = 'TEXT';const REMOVE = 'REMOVE';const REPLACE = 'REPLACE';let Index = 0;function diffAttr(oldAttrs,newAttrs)&#123; let patch = &#123;&#125;; for(let key in oldAttrs)&#123; if(oldAttrs[key] !== newAttrs[key])&#123; patch[key] = newAttrs[key] &#125; &#125; for(let key in newAttrs)&#123; if(!oldAttrs.hasOwnProperty(key))&#123; patch[key] = newAttrs[key] &#125; &#125; return patch;&#125;function diffChildren(oldChildren,newChildren,patches)&#123; oldChildren.forEach((child,idx)=&gt;&#123; recursion(child, newChildren[idx],++Index,patches) &#125;)&#125;function isString(node)&#123; return typeof node === \"string\";&#125;function recursion(oldNode,newNode,index,patches)&#123; let currentPatch = []; //每个元素都有一个补丁对象 if(!newNode)&#123; currentPatch.push(&#123;type: REMOVE, index&#125;) &#125;else if(isString(oldNode)&amp;&amp;isString(newNode))&#123; if(oldNode !== newNode)&#123; currentPatch.push(&#123;type: TEXT, text: newNode&#125;) &#125; &#125;else if(oldNode.type === newNode.type)&#123; let attrs = diffAttr(oldNode.props,newNode.props) if(Object.keys(attrs).length&gt;0)&#123; currentPatch.push(&#123;type: ATTRS,attrs&#125;) &#125; //如果有子节点，遍历子节点 diffChildren(oldNode.children,newNode.children,patches); &#125;else&#123; //说明节点被替换了 currentPatch.push(&#123;type: REPLACE, newNode: newNode&#125;) &#125; if(currentPatch.length&gt;0)&#123; // 将元素和补丁对应起来，放入大的补丁包中 patches[index] = currentPatch; &#125;&#125;function Diff(oldTree,newTree)&#123; let patches = &#123;&#125;; //递归树 比较后的结果放入补丁包中 recursion(oldTree,newTree,Index,patches); return patches;&#125;export default Diff; 1234567891011121314151617//index.jsimport &#123;createElement,render,renderDom&#125; from './element';import Diff from './diff';let virtualDom1 = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['Angular']),])let virtualDom2 = createElement('ul',&#123;class: 'list2',id: 6&#125;,[ createElement('li',&#123;class: 'item'&#125;,['Html']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('div',&#123;class: 'item'&#125;,['Js']),])let patches = Diff(virtualDom1,virtualDom2)console.log(patches) //===&gt;打印出补丁包 补丁包如下 图2 2.4 把补丁包应用到真实DOM上创建一个patch.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445//patch.jsimport &#123; render ,Element,setAttr&#125; from \"./element\";let allPatches;let index = 0;//默认打补丁的序号function Patch(node,patches)&#123; allPatches = patches; walk(node) //给某个元素打补丁&#125;function doPatch(node,patches)&#123; patches.forEach(patch=&gt;&#123; switch(patch.type)&#123; case 'ATTRS': for(let key in patch.attrs)&#123; let value = patch.attrs[key]; if(value)&#123; setAttr(node,key,value) &#125;else&#123; node.removeAttribute(key) &#125; &#125; break; case 'TEXT': node.textContent = patch.text; break; case 'REPLACE': let newNode = (patch.newNode instanceof Element)? render(patch.newNode): document.createTextNode(patch.newNode); node.parentNode.replaceChild(newNode,node); break; case 'REMOVE': console.log('remove',node.parentNode); node.parentNode.removeChild(node); break; &#125; &#125;)&#125;function walk(node)&#123; let currentPatch = allPatches[index++]; let childNodes = node.childNodes; childNodes.forEach(child=&gt;walk(child)) if(currentPatch)&#123; doPatch(node,currentPatch) &#125;&#125;export default Patch; 1234567891011121314151617181920//index.jsimport &#123;createElement,render,renderDom&#125; from './element';import Diff from './diff';import Patch from './patch';let virtualDom1 = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['Angular']),])let virtualDom2 = createElement('ul',&#123;class: 'list2',id: 6&#125;,[ createElement('li',&#123;class: 'item'&#125;,['Html']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('div',&#123;class: 'item'&#125;,['Js']),])let el = render(virtualDom1)renderDom(el,window.root)let patches = Diff(virtualDom1,virtualDom2); //对比两个虚拟DOM的差异Patch(el,patches); //把差异应用到元素节点 这样就完成了一个简易的DOM-Diff算法，当然还有很多情况没有考虑到，比如根据列表根据key值交换位置…","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://blog.eyes487.top/tags/React/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://blog.eyes487.top/tags/虚拟DOM/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"简单请求和复杂请求","slug":"simple-and-complex-requests","date":"2019-10-08T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/10/08/simple-and-complex-requests.html","link":"","permalink":"http://blog.eyes487.top/2019/10/08/simple-and-complex-requests.html","excerpt":"","text":"当一个资源从与该资源本身所在的服务器不同的 域、协议 或 端口 请求一个资源时，资源会发起一个跨域 HTTP 请求。跨域资源共享(CORS) 是一种解决跨域的机制，它使用额外的 HTTP 头，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，那些可能对服务器数据产生副作用的 HTTP 请求方法 (复杂请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。 1.简单请求/复杂请求同时满足下列三大条件，就属于简单请求 请求方式只能是，get、post、head http请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID Content-Type只能取：application/x-www-form-urlencoded、nultipart/form-data、text/plain 其他请求都属于属于非简单请求 2.预检请求（Preflighted Requests）Preflighted Requests是CORS中一种透明服务器验证机制。预检请求首先需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，其目的就是为了判断实际发送的请求是否是安全的。 简单跨域请求不会发送options（预检请求），复杂跨域请求会发送options 3.如何避免发送options请求 如何避免发送options请求，就是尽可能使用简单请求啦~ 还可以通过给服务器设置请求头 Access-Control-Max-Age来避免发送options请求，浏览器一般会有一个默认值，但是都不长久，可以自己设置 1Access-Control-Max-Age: 600 //即预检请求的结果缓存10分钟 Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。也就是说，如果设置了10分钟的缓存，在10分钟内，所有请求第一次会产生options请求，第二次以及第二次以后就只发送真正的请求了。 ————-如果以上内容有不对的地方，欢迎大家指正————","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://blog.eyes487.top/tags/Http/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"实现MVVM原理","slug":"mvvm-principle","date":"2019-09-10T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/09/10/mvvm-principle.html","link":"","permalink":"http://blog.eyes487.top/2019/09/10/mvvm-principle.html","excerpt":"","text":"1.什么是MVVM简单来说，MVVM就是一种模式，把数据和视图进行关联的一种模式。最常见的就是应用于Vue中，实现了数据绑定和视图渲染，Vue 最独特的特性之一，是其非侵入性的响应式系统，当数据变化时，视图会做出相应的更新，当视图变化，数据也会相应更新，主要体现在Vue中双向绑定，主要通过表单元素设置v-model属性实现双向绑定。 放一张从网上找的图 Vue中一般这样引用 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data:&#123; message:'hello world' &#125; &#125;)&lt;/script&gt; 2.响应式原理分析 1、首先通过new Vue()执行初始化，对数据进行数据劫持 Observer，同时执行编译模板 Compile 2、在Observer中通过 Object.defineProperty / Proxy对数据进行劫持，其中有 get 和 set方法 ,在get中为每个key值创建一个Dep(依赖收集) 3、在 Compile 中执行模板编译的时候，可以知道哪些数据是动态绑定的，为每个数据创建一个Watcher，里面放的是数据的更新方法(Updater) 4、在创建这个Watcher的时候，可以通过Dep.target = this,把Watcher先保存下来，触发get方法把Watcher收进Dep中 ，通过dep.addSub()方法，在置空Dep.target 5、依赖收集完毕，在set方法中，设置新值的时候会触发set方法,设置dep.notify()通知所有更新方法更新,就完成了整个响应过程 所以数据key值，Dep, Watcher 是一对一对多的关系，每个数据值都有一个Dep(相当于管家)，里面管理着多个Watcher，数据在页面上引用一次，就会产生一个Watcher PS: vue2中已经不采用这种方式了，每个组件会生成一个Watcher，组件中的任何key变化都会去触发Watcher的更新函数，所有有了虚拟dom来判断最小变化，之后 会在Vue源码解析中介绍。 3.Vue中的数据响应化实现要实现数据双向绑定主要有三个核心点： 模板的编译 数据劫持,观察数据变化 watcher最后通过入口函数MVVM，整合三个核心点 首先自己创建一个MVVM.html 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message.a\"/&gt; &#123;&#123;message.a&#125;&#125; &lt;/div&gt; //这里会引用自己写的一些方法... &lt;script src=\"watcher.js\"&gt;&lt;/script&gt; &lt;script src=\"observer.js\"&gt;&lt;/script&gt; &lt;script src=\"compile.js\"&gt;&lt;/script&gt; &lt;script src=\"MVVM.js\"&gt;&lt;/script&gt; &lt;script&gt; let vm = new MVVM(&#123; el: '#app', //这里可以传字符串，也可以传document元素节点 data:&#123; message: &#123; a: 'hello World!' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 创建一个MVVM.js文件 123456789101112131415161718192021222324252627282930//MVVM.jsclass MVVM&#123; constructor(options)&#123; //把可用的东西挂载在实例上 this.$el = options.el; this.$data = options.data; //如果有要编译的模板 if(this.$el)&#123; //数据劫持，把对象的所有属性改为set和get方法 new Observer(this.$data); this.proxyData(this.$data); //用数据和元素进行编译 new Compile(this.$el,this) &#125; &#125; //把数据代理到this上，可以直接通过this取 proxyData(data)&#123; Object.keys(data).forEach(key=&gt;&#123; Object.defineProperty(this,key,&#123; get()&#123; return data[key] &#125;, set(newValue)&#123; data[key] = newValue &#125; &#125;) &#125;) &#125;&#125; 下面就开始用代码一步步实现MVVM原理。 2.1 模板编译新建compile.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140class Compile&#123; constructor(el,vm)&#123; this.el = this.isElementNode(el)?el:document.querySelector(el); this.vm = vm; if(this.el)&#123; //开始编译 //1.先把真是dom移入内存中Fragment（性能） let fragment = this.node2Fragment(this.el); //2.编译 =》提取想要的元素节点 v-model和文本节点&#123;&#123;&#125;&#125; this.compile(fragment) //把编译后的Fragment移回页面 this.el.appendChild(fragment) &#125; &#125; /** * * @param &#123;辅助方法&#125; node */ //判断是否是元素节点 isElementNode(node)&#123; return node.nodeType === 1; &#125; //是不是指令 isDirective(name)&#123; return name.includes('v-') &#125; /** * 核心方法 * @param &#123;*&#125; el */ compileElement(node)&#123; //带v-model let attrs = node.attributes;//取出当前节点属性 Array.from(attrs).forEach(attr=&gt;&#123; //判断属性名字是否包含v- let attrName = attr.name; if(this.isDirective(attrName))&#123; //取到对应的值放到节点中 let expr = attr.value; let [,type] = attrName.split('-'); //node this.vm.$data CompileUtil[type](node,this.vm,expr) &#125; &#125;) &#125; compileText(node)&#123; //带&#123;&#123;&#125;&#125; let expr = node.textContent; //取文本中的内容 let reg = /\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g; if(reg.test(expr))&#123; //node this.vm.$data text CompileUtil['text'](node,this.vm,expr) &#125; &#125; compile(fragment)&#123; let childNodes = fragment.childNodes; Array.from(childNodes).forEach(node=&gt;&#123; if(this.isElementNode(node))&#123; //是元素节点,编辑元素 this.compileElement(node); //元素节点中可能还有节点 this.compile(node) &#125;else&#123; //文本节点,编译节点 this.compileText(node); &#125; &#125;) &#125; node2Fragment(el)&#123; let fragment = document.createDocumentFragment(); let firstChild; while(firstChild = el.firstChild)&#123; fragment.appendChild(firstChild); &#125; return fragment; &#125;&#125;CompileUtil =&#123; getVal(vm,expr)&#123;//获取实例上对应的数据 expr = expr.split('.'); //\"message.a\" =&gt; [message,a] return expr.reduce((prev,next)=&gt;&#123; //vm.$data.a return prev[next] &#125;,vm.$data); &#125;, setVal(vm,expr,value)&#123; expr = expr.split('.'); //收敛 return expr.reduce((prev,next,currentIndex)=&gt;&#123; if(currentIndex === expr.length -1)&#123; return prev[next] = value; &#125; return prev[next] &#125;,vm.$data) &#125;, getTextVal(vm,expr)&#123; return expr.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g,(...arguements)=&gt;&#123; return this.getVal(vm,arguements[1]) &#125;) &#125;, text(node,vm,expr)&#123; //文本处理 let updateFn = this.updater['textUpdater']; expr.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g,(...arguements)=&gt;&#123; new Watcher(vm,arguements[1],newValue=&gt;&#123; //如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容 updateFn &amp;&amp; updateFn(node,this.getTextVal(vm,expr)) &#125;) &#125;) updateFn &amp;&amp; updateFn(node,this.getTextVal(vm,expr)) &#125;, model(node,vm,expr)&#123; //输入框处理 let updateFn = this.updater['modelUpdater']; //这里加一个监控，数据变化了。应该调用这个watch的cb new Watcher(vm,expr,newValue=&gt;&#123; updateFn &amp;&amp; updateFn(node,this.getVal(vm,expr)) &#125;) node.addEventListener('input',(e)=&gt;&#123; let newValue = e.target.value; this.setVal(vm,expr,newValue) &#125;) updateFn &amp;&amp; updateFn(node,this.getVal(vm,expr)) &#125;, updater:&#123; //文本更新 textUpdater(node,value)&#123; node.textContent = value; &#125;, //输入框更新 modelUpdater(node,value)&#123; node.value = value; &#125; &#125;&#125; 2.2 数据劫持（Observer）新建observer.js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Observer&#123; constructor(data)&#123; this.observe(data) &#125; observe(data)&#123; //要对这个data数据将原有的属性改成set和get的形式 if(!data || typeof data !== \"object\")&#123; return &#125; //将所有数据一一劫持，先获取到data的key和value Object.keys(data).forEach(key=&gt;&#123; //劫持 this.defineReactive(data,key,data[key]); this.observe(data[key]);//深度递归劫持 &#125;) &#125; //定义响应式 defineReactive(obj,key,value)&#123; let that = this; let dep = new Dep(); Object.defineProperty(obj,key,&#123; enumerable: true, //可枚举 configurable: true, //可修改 get()&#123; //当取值的时候调用的方法 // 收集依赖 在创建Watcher的时候，会将watcher赋值给Dep.target,所以可以将他加入依赖中 Dep.target &amp;&amp; dep.addSub(Dep.target) return value; &#125;, set(newValue)&#123; //当给data属性中设置值的时候， 更改获取的属性的值 if(newValue != value)&#123; that.observe(newValue); value = newValue; dep.notify(); //通知所有人，数据更新了 &#125; &#125; &#125;) &#125;&#125;class Dep&#123; constructor()&#123; //订阅的数组 this.subs = []; &#125; addSub(watcher)&#123; this.subs.push(watcher) &#125; notify()&#123; this.subs.forEach(watcher=&gt;watcher.update()) &#125;&#125; 2.3 watcher新建watcher.js文件,给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法 1234567891011121314151617181920212223242526272829class Watcher&#123; constructor(vm,expr,cb)&#123; this.vm = vm; this.expr = expr; this.cb = cb; //先获取旧值 this.value = this.get(); &#125; getVal(vm,expr)&#123;//获取实例上对应的数据 expr = expr.split('.'); //\"message.a\" =&gt; [message,a] return expr.reduce((prev,next)=&gt;&#123; //vm.$data.a return prev[next] &#125;,vm.$data); &#125; get()&#123; Dep.target = this; let value = this.getVal(this.vm,this.expr); Dep.target = null; return value; &#125; update()&#123; let newValue = this.getVal(this.vm,this.expr); let oldValue = this.value; if(newValue != oldValue)&#123; this.cb(newValue) &#125; &#125;&#125; 4. Proxy在Vue3.0中将会使用Proxy实现数据的双向绑定，Proxy 是ES6 中新增的功能，它可以用来自定义对象中的操作。 1234//语法let p = new Proxy(target, handler);//target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。//handlew 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 数据劫持的简单实现 1234567891011121314151617181920212223242526function render() &#123; console.log('模拟视图的更新')&#125;let obj = &#123; message: 'hello world',&#125;let handler = &#123; get(target, key) &#123; // 如果取的值是对象就在对这个对象进行数据劫持 if (typeof target[key] == 'object' &amp;&amp; target[key] !== null) &#123; return new Proxy(target[key], handler) &#125; return Reflect.get(target, key) &#125;, set(target, key, value) &#123; if (key === 'length') return true render(); return Reflect.set(target, key, value) &#125;&#125;let proxy = new Proxy(obj, handler)console.log(proxy.message) // hello worldproxy.message = 'my name is eyes487' // 支持新增属性console.log(proxy.message) // 模拟视图的更新 my name is eyes487 用这种方法的优点： defineProperty只能监听某个属性，不能对全对象监听 不会对源对象进行污染，代理返回了一个新的对象 可以省去循环，提升效率 乐意监听数组，不用再去对单独的随想做特异性操作 代码可以精简很多 但目前proxy兼容性还不是很好* 源码地址","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://blog.eyes487.top/tags/MVVM/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"浅谈this指向","slug":"analyse-of-this","date":"2019-08-24T00:00:00.000Z","updated":"2020-01-29T14:27:10.581Z","comments":true,"path":"2019/08/24/analyse-of-this.html","link":"","permalink":"http://blog.eyes487.top/2019/08/24/analyse-of-this.html","excerpt":"","text":"本文出自 《你不知道的js》，看过之后总是容易忘记，所以总结记录一下。 1.this到底是什么 this是在 运行时 绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数调用时，会创建一个活动记录（也称执行上下文）。这个记录会包含函数在哪里调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到。 2.this绑定规则2.1 默认绑定非严格模式下，指向全局对象Windows 1234567891011121314151617181920//严格模式function foo()&#123; \"use strict\"; console.log(this.a);&#125;var a = 2;foo()// TypeError: this is undefinedfunction foo()&#123; console.log(this.a);&#125;var a = 2;(function()&#123; \"use strict\"; foo()//2&#125;) 2.2 隐式绑定12345678function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;obj.foo(); //2 无论是直接在obj中定义还是先定义在添加为引用类型，这个函数严格来说都不属于obj对象。然而，调用位置会使用obj上下文来引用函数，因此可以说函数被调用时obj对象拥有它或包含它。 1234567891011//隐式丢失function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;var bar = obj.foo; // 函数别名var a = \"ooop\"; //a是全局对象的属性bar(); // \"ooop\" 虽然bar是obj.foo的一个引用,但是实际上，它引用的是foo函数本身，所以此处应用了默认绑定。 参数传递也是一种隐式复制，传入函数时也会被隐式赋值 12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;var a = \"ooop\"; //a是全局对象的属性setTimeout(obj.foo, 100); //\"ooop\" 2.3 显式绑定Js提供的绝大部分函数以及你自己所创建的函数都可以使用call()和apply()方法 1234567function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2,&#125;foo.call(obj); //2 这样还是会存在丢失绑定的问题 硬绑定（不会丢失绑定） 1234567891011121314151617181920212223242526function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2,&#125;var bar = function()&#123; foo.call(obj);&#125;bar(); //2setTimeout(bar,100); //2bar.call(Window); //2 硬绑定的bar不可能在修改它的this//-----使用bind-----------function foo(something)&#123; console.log(this.a, something); return thi.a + something;&#125;var obj =&#123; a: 2&#125;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); //5 2.4 new 绑定 首先我们重新定义一下JavaScript中的 “构造函数”。在js中，构造函数只是一些使用new操作符时被调用的函数。他们并不会属于某个类，也不会实例化一个类。实际上，他们甚至都不能说是一种特殊的函数类型，他们只是被new操作符调用的普通函数。 12345function foo()&#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); //2 3.优先级 函数是否在new中调用（new 绑定)?如果是的话this绑定的是新创建的对象。var bar = new foo(); 函数是否通过call，apply（显示绑定）或者硬绑定调用？ 如果是的话，this绑定的是指定的对象var bar = foo.call(obj); 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。var bar = obj.foo(); 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象var bar = foo(); 就是这样。对于正常的函数调用来说，理解了这些知识点就可以明白this的绑定原理了。不过，凡事都有列外 4.绑定例外4.1 如果把null或者undefined最为this的绑定对象传入call、apply或者bind，这些纸在调用时会被忽略。 一种非常常见的做法是使用apply（）来展开一个数组，并当做参数传入一个函数。类似地，bind（）可以对函数进行柯里化（预先设置一些参数） 123456789function foo(a,b)&#123; console.log(\"a:\" + a+ \",b:\"+ b+);&#125;//把数组展开成参数foo.apply(null,[2,3]); //a:2, b:3//使用bind（）进行柯里化var bar = foo.bind(null,2);bar(3); //a:2 , b:3 然而，总是使用null来忽略this绑定会产生一种副作用 更安全的做法是传入一个特殊对象，把this绑定到这个特殊对象不会对程序产生副作用 123456789101112function foo(a,b)&#123; console.log(\"a:\" + a+ \",b:\"+ b+);&#125;//我们的DMZ空对象var の = Object.create(null);//把数组展开成参数foo.apply(null,[2,3]); //a:2, b:3//使用bind（）进行柯里化var bar = foo.bind(の,2);bar(3); //a:2 , b:3 4.2 间接引用调用这个函数会应用默认绑定规则 12o.foo(); //3(p.foo = o.foo)(); //2 4.3 软绑定 softBind()把this绑定到指定对象上后，但是可以使用隐式绑定和显示绑定来更改this 123456789101112131415161718function foo()&#123; console.log(\"name: \"+this.name);&#125;var obj1=&#123;name:\"obj1\"&#125;, obj2=&#123;name:\"obj2\"&#125;, obj3=&#123;name:\"obj3\"&#125;;var fooOBJ=foo.softBind(obj1);fooOBJ();//\"name: obj1\" 在这里软绑定生效了，成功修改了this的指向，将this绑定到了obj1上 obj2.foo=foo.softBind(obj1);obj2.foo();//\"name: obj2\" 在这里软绑定的this指向成功被隐式绑定修改了，绑定到了obj2上 fooOBJ.call(obj3);//\"name: obj3\" 在这里软绑定的this指向成功被硬绑定修改了，绑定到了obj3上 setTimeout(obj2.foo,1000);//\"name: obj1\"/*回调函数相当于一个隐式的传参，如果没有软绑定的话，这里将会应用默认绑定将this绑定到全局环境上，但有软绑定，这里this还是指向obj1*/ 5.this词法 ES6中有一种特殊函数类型：箭头函数 箭头函数会捕获调用函数时的this，一经绑定无法修改（new也不行） 如果经常编写this风格的代码，但是绝大部分时候都会使用 self = this 或者 箭头函数 来否定this机制，那或许应该： 只使用词法作用域并完全抛弃错误this风格的代码 完全才用this风格，在必要时使用 bind（），尽量避免使用 self = this 和 箭头函数","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Js","slug":"Js","permalink":"http://blog.eyes487.top/tags/Js/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]}]}