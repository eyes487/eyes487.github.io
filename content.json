{"meta":{"title":"eyes487的博客","subtitle":null,"description":"knowledge point record","author":"xm","url":"http://blog.eyes487.top"},"pages":[{"title":"categories","date":"2019-10-10T12:28:01.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"categories/index.html","permalink":"http://blog.eyes487.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack深入学习（三）：优化篇","slug":"webpack-three","date":"2020-05-23T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/05/23/webpack-three.html","link":"","permalink":"http://blog.eyes487.top/2020/05/23/webpack-three.html","excerpt":"","text":"前两篇文章，讲解了一些webpack的基本配置，但是随着我们代码越来越多，我们构建的时间也会越来越长，今天就会对webpack做一些优化配置，帮助我们减少构建时间，同时也帮助我们优化输出的代码质量，让代码在生产环境能够更快的让用户访问到。 一、缩⼩文件范围优化loader配置,loader是一个消性能的大户，官方不建议使用过多的loader，但是我们又不能不用 test include exclude 三个配置项来缩⼩loader的处理范围 include: 只去哪里查找 exclude: 排除，不去哪里查找1234&#123; test: /\\.css$/, include: path.resolve(__dirname,\"./src\"), &#125; 二、resolve优化resolve.modules配置resolve.modules 用于配置webpack去哪些目录下寻找第三方模块，默认是[‘node_modules’],如果没有找到，就会去上一级⽬目录../node_modules 找，再没有会去../../node_modules中找，以此类推，和Node.js的模块寻找机制很类似.如果我们的第三方模块都安装在了项目根目录下，就可以直接指明这个路径。 123456//webpack.config.jsmodule.exports=&#123; resolve:&#123; modules: [path.resolve(__dirname, \"./node_modules\")] &#125;&#125; 优化resolve.alias配置resolve.alias 配置通过别名来将原导⼊路径映射成一个新的导⼊路径拿react为例，我们引⼊的react库，一般存在两套代码 cjs: 采用commonJS规范的模块化代码 umd: 已经打包好的完整代码，没有采用模块化，可以直接执⾏ 默认情况下，webpack会从⼊口文件./node_modules/bin/react/index开始递归解析和处理依赖的文件。我们可以直接指定文件，避免这处的耗时。使用绝对路径也可以减少构建时间，因为相对路径最后也是转换为绝对路径 12345678910//webpack.config.jsmodule.exports=&#123; resolve:&#123; modules: [path.resolve(__dirname, \"./node_modules\")], alias: &#123; react: path.resolve(__dirname,\"./node_modules/react/umd/react.production.min.js\" ), \"react-dom\": path.resolve(__dirname,\"./node_modules/react-dom/umd/react-dom.production.min.js\") &#125; &#125;&#125; 优化resolve.extensions配置resolve.extensions在导⼊语句没带⽂件后缀时，webpack会自动带上后缀后，去尝试查找文件是否存在extensions就是来配置这个后缀列表的，webpack默认只支持js和json 文件，如果想支持其他的，就可以在这个列表中添加。 1234567//webpack.config.jsmodule.exports=&#123; resolve:&#123; //... extensions: ['.js','.json','.ts',...] &#125;&#125; 但是去查找列表需要消耗时间，所以不建议设置很多 后缀尝试列表尽量的小 导入语句尽量的带上后缀 频率高的放在最前面 三、externals优化cdn静态资源前提条件： 公司有cdn 服务 静态资源有部署到cdn 有链接了 想使用cdn，因为cdn有很多好处嘛，加快静态文件加载速度等这样我们在打包的时候，bundle ⽂件里，就不用打包进去这个依赖了，体积会更⼩ 假如我们使用jquery或者echarts等，想使用cdn资源，在index.html 中使用标签引入 12&lt;!-- 其他代码 --&gt;&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt; 我们希望在使用时，仍然可以通过import 的⽅式去引用(如import $ from &#39;jquery&#39;)，并且希望webpack不会对其进行打包，此时就可以配置externals 12345678//webpack.config.jsmodule.exports=&#123; //... externals: &#123; //jquery通过script引入之后，全局中即有了 jQuery 变量 'jquery': 'jQuery' &#125;&#125; 其实，如果你在index.html 中已经引入jquery 的资源，可以不用再import 中了引入也可以使用了，但是为了格式统一，所以在文件中引入了 四、publicPath(CDN)CDN 通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入CDN，需要把网页的静态资源上传到CDN服务上，在访问这些资源时，使⽤CDN服务提供的URL。 1234567//webpack.config.jsmodule.exports=&#123; //... output:&#123; publicPath: '//cdnURL.com', //指定存放JS文件的CDN地址 &#125;&#125; 这样设置之后，在打包出来的文件，在index.html 引入的时候，会自动帮我们加上面指定的地址。我们需要把打包出的文件自己上传到cdn服务器上 五、MiniCssExtractPlugin 抽离css之前我们在说到处理css的时候，css打包都是直接打包进js文件的，css文件也可以抽离出来单独成一个文件。因为单独生成css,css可以和js并行下载，提高页⾯加载效率 安装依赖 1npm i mini-css-extract-plugin -D 1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");//webpack.config.jsmodule.exports=&#123; module:&#123; rules:[ &#123; test: /\\.less$/, //less-loaser: 会把less转换为css文件 use: [ // \"style-loader\", //不再需要style-loader，用MiniCssExtractPlugin.loader代替 MiniCssExtractPlugin.loader, &#123; loader: \"css-loader\", options: &#123; //css modules modules: true &#125; &#125;, \"less-loader\"] &#125; ] &#125; plugins: [ newMiniCssExtractPlugin(&#123; filename: \"css/[name]_[contenthash:6].css\", chunkFilename: \"[id].css\" &#125;) ]&#125; 六、压缩压缩css需要使用到两个插件cssnano做多方面的的优化，以确保最终生成的文件 对生产环境来说体积是最小的 安装依赖 12npm i cssnano -D npm i optimize-css-assets-webpack-plugin -D 1234567891011121314const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");nodule.exports=&#123; plugins:[ new OptimizeCSSAssetsPlugin(&#123; cssProcessor: require(\"cssnano\"), //引⼊入cssnano配置压缩选项 cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125; &#125;) ]&#125; 压缩html之前我们提到了html-webpack-plugin 可以帮助我们创建html模板，引入js文件，它还有很多可配置的属性 123456789101112131415module.exports=&#123; plugins:[ new htmlWebpackPlugin(&#123; title: \"测试\", template: \"./index.html\", filename: \"index.html\", minify: &#123; // 压缩HTML⽂文件 removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换符 minifyCSS: true // 压缩内联css &#125; &#125;), ]&#125; 七、tree Shakingwebpack2.x 开始⽀持 tree shaking 概念，顾名思义，&quot;摇树&quot;，清除⽆用 css,js(Dead Code)Dead Code 一般具有以下几个特征 码不会被执⾏，不可到达 代码执⾏的结果不会被用到 代码只会影响死变量(只写不读) Js tree shaking只⽀持ES module的引入方式！！！！ Css tree shaking安装依赖 1npm i glob-all purify-css purifycss-webpack -D 123456789101112131415const PurifyCSS=require('purifycss-webpack') const glob=require('glob-all')module.exports=&#123; //... plugins:[ // 清除⽆用 css new PurifyCSS(&#123; paths: glob.sync([ // 要做 CSS Tree Shaking 的路径文件 path.resolve(__dirname, './src/*.html'), // 请注意，我们同样需要对 html 文件进行 tree shaking path.resolve(__dirname, './src/*.js') ]) &#125;) ]&#125; 这样，在页面中并没有用到的css就会被摇掉 Js tree shaking只支持import⽅式引入，不支持commonjs的方式引⼊ 只需要在配置文件中配置就行，不需要额外的插件 123optimization: &#123; usedExports: true// 哪些导出的模块被使⽤用了了，再做打包&#125; 只要mode是production就会生效，develpoment的tree shaking是不⽣生效的，因为webpack为了⽅便你的调试可以查看打包后的代码注释以辨别是否生效。 生产模式不需要做上面配置，默认开启 副作用12345//package.json\"sideEffects\":false //正常对所有模块进行tree shaking , 仅生产模式有效，需要配合usedExports//或者在数组面排除不需要tree shaking的模块\"sideEffects\":['*.css','@babel/polyfill'] 八、code Splitting单页面应用spa:打包完成，所有页面只生成一个bundle.js 代码体积变大，不利于下载 没有合理利用浏览器资源(比如谷歌，可以同时发送6个tcp连接) 多页面应用mpa:如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包，公共代码只需要下载一次缓存起来，避免重复下载 1234567module.expports=&#123; optimization: &#123; splitChunks: &#123; chunks: \"all\", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件 &#125;, &#125;&#125; splitChunks还有一些其他配置 12345678910111213141516171819202122232425262728293031optimization: &#123; splitChunks: &#123; chunks: 'async',//对同步 initial，异步 async，所有的模块有效 all minSize: 30000,//最⼩尺寸，当模块大于30kb maxSize: 0,//对模块进行二次分割时使用，不推荐使用 minChunks: 1,//打包⽣成的chunk文件最少有几个chunk引用了这个模块 maxAsyncRequests: 5,//最⼤异步请求数，默认5 maxInitialRequests: 3,//最大初始化请求书，⼊口文件同步请求，默认3 automaticNameDelimiter: '-',//打包分割符号 name: true,//打包后的名称，除了布尔值，还可以接收一个函数function cacheGroups: &#123;//缓存组 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, name:\"vendor\", // 要缓存的分隔出来的 chunk 名称 priority: -10//缓存组优先级数字越大，优先级越高 &#125;, other:&#123; chunks: \"initial\", // 必须三选一： \"initial\" | \"all\" | \"async\"(默认就是async) test: /react|lodash/, // 正则规则验证，如果符合就提取 chunk, name:\"other\", minSize: 30000, minChunks: 1, &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true//可设置是否重⽤用该chunk &#125; &#125; &#125; &#125; 九、Scope Hoisting作⽤域提升（Scope Hoisting）是指 webpack 通过 ES6 语法的静态分析，分析出模块之间的依赖关系，尽可能地把模块放到同一个函数中。下⾯通过代码示例来理解 12345// hello.jsexport default'Hello, Webpack';// index.jsimport str from'./hello.js';console.log(str); 打包后，这两个文件会被打包成一个文件 通过配置 12345module.exports=&#123; optimization:&#123; concatenateModules: true &#125;&#125; 这样，hello.js和index.js就合并成一个函数了，这样打包出来的文件会更小，运行更快 十、使用工具量化speed-measure-webpack-plugin 可以测量各个插件和loader所花费的时间 安装依赖 1npm i speed-measure-webpack-plugin -D 1234567//webpack.config.jsconst SpeedMeasurePlugin=require(\"speed-measure-webpack-plugin\");const smp=newSpeedMeasurePlugin();const config= &#123; //...webpack配置&#125;module.exports=smp.wrap(config); webpack-bundle-analyzer 分析webpack打包后的模块依赖关系安装依赖 1npm i webpack-bundle-analyzer -D 12345678const BundleAnalyzerPlugin=require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports=merge(baseWebpackConfig, &#123; //.... plugins: [ //... new BundleAnalyzerPlugin(), ]&#125;) 启动webpack 构建，会默认打开一个窗⼝ 十一、DLLPlugin 打包插件第三方库，提前编译Dll动态链接库 ，其实就是做缓存 项⽬中引⼊了很多第三方库，这些库在很长的一段时间内，基本不会更新，打包的时候分开打包来提升打包速度，⽽DllPlugin 动态链接库插件，其原理就是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导⼊的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取，这是帮助我们在开发 的时候，提升速度，对生产不会有什么影响 动态链接库只需要被编译一次，项目中用到的第三方模块，很稳定，例如react,react-dom，只要没有升级的需求webpack已经内置了对动态链接库的支持 DllPlugin:⽤于打包出一个单独的动态链接库文件 DllReferencePlugin：⽤于在主要的配置文件中引⼊DllPlugin插件打包好的动态链接库文件 首先，新建一个webpack.dll.config.js,这里就用react和react-dom举例 12345678910111213141516171819202122const path = require(\"path\");const &#123;DllPlugin&#125; = require(\"webpack\");module.exports = &#123; mode: \"development\", entry: &#123; react: [\"react\", \"react-dom\"] //! node_modules? &#125;, output: &#123; path: path.resolve(__dirname, \"./dll\"), filename: \"[name].dll.js\", library: \"react\" &#125;, plugins: [ new DllPlugin(&#123; // manifest.json文件的输出位置 path: path.join(__dirname, \"./dll\", \"[name]-manifest.json\"), // 定义打包的公共vendor文件对外暴露的函数名 name: \"react\" &#125;) ]&#125; 在package.json中添加 1\"dev:dll\": \"webpack --config ./webpack.dll.config.js\" 然后运行 npm run dev:dll打包完成，你会发现多了一个dll文件，里面有react.dll.js文件，这时已经单独打包出来了 dll⽂件包含了⼤量模块的代码，这些模块被存放在一个数组里。用数组的索引号为ID,通过变量将自己暴露在全局中，就可以在window.xxx访问到其中的模块 Manifest.json 描述了与其对应的dll.js包含了哪些模块，以及ID和路路径。 那接下来看看如何使用??在配置文件中webpack.dev.config.js 123new DllReferencePlugin(&#123; manifest: path.resolve(__dirname,\"./dll/react-manifest.json\") &#125;) 然后还需要在模板文件中，添加链接 12&lt;!-- src/index.html --&gt;&lt;script type=\"text/javascript\" src=\"../dll/react.dll.js\"&gt;&lt;/script&gt; 手动添加使用，体验不好，这里推荐使用add-asset-html-webpack-plugin插件帮助我们做这个事情。 安装 1npm i add-asset-html-webpack-plugin -D 它会将我们打包后的 dll.js ⽂件注入到我们生成的 index.html 中。在 webpack.base.config.js ⽂件中进⾏更改 123new AddAssetHtmlWebpackPlugin(&#123; filepath: path.resolve(__dirname, '../dll/react.dll.js') // 对应的 dll ⽂文件路路径 &#125;) 在webpack5中，我们使用HardSourceWebpackPlugin来做优化,它会缓存在硬件上，和DLL相比，一样的优化效果，但是使⽤却及其简单 提供中间缓存的作⽤用 首次构建没有太大的变化 第二次构建时间就会有较大的节省 安装 1npm i hard-source-webpack-plugin -D 123456const HardSourceWebpackPlugin = require('hard-source-webpack-plugin')module.exports = &#123; plugins: [ new HardSourceWebpackPlugin() ]&#125; 十二、happyPack运行在 Node之上的Webpack是单线程模型的，也就是说Webpack需要⼀个一个地处理任务，不能同时处理多个任务。Happy Pack就能让Webpack做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。从而发挥多核 CPU 电脑的威力 安装 1npm i happyPack -D 在配置文件中 1234567891011121314151617181920212223242526272829303132333435363738394041const os = require('os')const Happypack = require('happypack')const happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;)//根据操作系统来判断开启几个进程module.exports = &#123; //... module:&#123; rules:[ //... &#123; test: /\\.jsx?$/, exclude: /node_modules/, use: [&#123; // 一个loader对应⼀一个id loader: \"happypack/loader?id=babel\" &#125;] &#125;, &#123; test: /\\.css$/, include: path.resolve(__dirname, \"./src\"), use: [\"happypack/loader?id=css\"] &#125; ], &#125;, plugins:[ //... new HappyPack(&#123; // ⽤唯一的标识符id，来代表当前的HappyPack是⽤来处理一类特定的文件 id: 'babel', // 如何处理理.js⽂文件，⽤用法和Loader配置中⼀一样 loaders: ['babel-loader?cacheDirectory'], threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: \"css\", loaders: [\"style-loader\", \"css-loader\"] &#125;), ]&#125; happypack主要是用来处理loader的，因为它比较费时。在module中定义了几个id，下面就要创建几个happaypack的实例 使用happypack不一定会使打包加快，因为开启多线程需要时间，这不适用于小项目，构建时间较久的时候才需要用到这个 需要注意： happypack和mini-css-extract-plugin一起使用，会有问题,了解更多","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.eyes487.top/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://blog.eyes487.top/tags/webpack/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"webpack深入学习（二）：进阶篇","slug":"webpack-two","date":"2020-05-17T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/05/17/webpack-two.html","link":"","permalink":"http://blog.eyes487.top/2020/05/17/webpack-two.html","excerpt":"","text":"上一篇文章，讲了一些webpack的基础配置，算是对webpack的入门。今天会拓展一些真实项目中可能会用到的配置。如果不知道如何做基础配置的，请先看《webpack深入学习（一）：基础配置篇》 一、webpack-dev-server上一篇文章中，我们是使用npx webpack进行打包，每修改一次文件，都需要通过这个命令打包，这也太不方便了吧。所以webpack为我们提供了一个插件webpack-dev-server 1.1 webpack-dev-server 启动项目首先安装依赖 1npm i webpack-dev-server -D 然后在package.json中设置 1234\"scripts\": &#123; //... \"dev\": \"webpack-dev-server\" &#125;, 启动项目 1npm run dev 看到下面这个提示，就说明已经启动成功了，在http://localhost:8080/这样之后修改页面，它就会自动帮我们刷新了。这时，会发现，dist目录下被清空了，因为现在都是通过内存来读取文件，这样反应速度会更快了。还可以在devserver中做一些配置项 12345678910//webpack.config.jsmodule.exports=&#123; //... devserver:&#123; contentBase: path.resolve(__dirname,\"./dist\")，//把这里当成静态目录了 open: true, //是都自动打开浏览器窗口 port: 8080, //... &#125;&#125; 1.2 解决跨域这是我们项目中经常互遇到的一个问题，以前经常都会用到jsonp,cors来跨域，但是现在，webpack-dev-server为我们提供了非常简单的方法，就可以支持跨域了。上一篇文章中，我们提到了webpack-dev-server来帮我们启动一个热更新服务器。 123456789101112//webpack.config.jsmodule.exports = &#123; //... devServer: &#123; contentBase: path.resolve(__dirname,\"./dist\")，//把这里当成静态目录了 open: true, //是都自动打开浏览器窗口 port: 8080, proxy: &#123; '/api': 'http://localhost:3000' &#125; &#125;&#125;; 通过上面的配置，我们就可以跨域请求数据了。http://localhost:3000是服务器的地址，这相当于一个反向代理，就是代理了服务端的地址，这样我们在浏览器中，是不知道我们向哪个服务器发送的请求，只能看到本机的地址。 1.3 本地mock数据现在项目开发，基本都是前后端分离的，我们写完静态页面之后，可能后端接口还没有写完，我们不能一直就等着后端的接口呀。所以开发之前会给出一个接⼝⽂档，和接⼝联调⽇期的，我们前端就可以本地mock数据，不打断⾃⼰的开发节奏。 dev-server给我们提供了两个钩子，分别叫before和after,表示加载dev-server之前和之后要做的事情 12345678910111213141516module.exports = &#123; //... devServer: &#123; //... before(app,server)&#123; app.get('/api/mock.json',(req,res)=&gt;&#123; res.json(&#123; data: 'hello world' &#125;) &#125;) &#125;, after()&#123; //... &#125; &#125;&#125;; 这样设置好之后，我们启动这个 dev-server服务器，也就是npm run dev,然后http://localhost:8080/api/mock.json就可以访问了，它会给我们返回hello world,这样就可以来模拟后台接口返回数据了。根据接口文档的格式，先写好请求格式，等到之后联调接口，就只需要替换一下地址就可以啦，是不是很方便呢。。。 1.4 Hot Module Replacement (HMR:热模块替换)之前我们设置dev-server,他是通过刷新整个页面，更新代码，那这样的话，我们在页面上做的操作就会没有了，那我们要是想要只更新我们更改的代码应该怎么办呢？？？HMR 就是帮我们做这件事情的，它只会刷新局部，也就是我们更改代码的地方，而我们之前在页面的操作还会保留着。 启动 hmr , 在dev-server中设置 hot: true, 在头部引入 webpack, 需要使用 webpack.HotModuleReplacementPlugin() 12345678910111213//webpack.config.jsconst webpack = require('webpack')devServer: &#123; contentBase: \"./dist\", open: true, hot:true&#125;,plugins： [ //... new webpack.HotModuleReplacementPlugin()] 通过上面的配置，我们试一下，发现浏览器还是刷新了，那要注意了，这里还有一点，需要增加一个 hotOnly: true 12345678devServer: &#123; contentBase: \"./dist\", open: true, hot:true, //即便HMR不⽣效，浏览器也不⾃动刷新，就开启hotOnly //这为什么会失效呢??它会和MiniCssExtractPlugin.loader有冲突，如何开启了这个css，那么热模块替换就会失效 hotOnly:true&#125;, 上面我们设置了hotOnly:true,这样，热模块替换就开启成功了。这里有一个注意的地方： HMR 有时会不生效，这是它和 MiniCssExtractPlugin.loader 会冲突，这个插件是用来提取css成单独文件的，后面在优化部分我们会讲到。。所以，我们一般推荐开发模式下不开启MiniCssExtractPlugin插件，开发模式下也不需要， 在生产模式下才提取css，而且生产模式下也不需要热模块替换了。 上面说的这些，只是css 的 HMR，下面我们在看看 js的 HMR 需要使⽤module.hot.accept来观察模块更新 从⽽更新在入口的地方 123456// index.jsif (module.hot) &#123; module.hot.accept(\"./other.js\", function() &#123; //.... &#125;);&#125; 在最上层入口，通过监听某个模块，来做一些替换操作。。 这种方式，好像不够高效，那我们平时项目都是怎么做的呢？？？现在我们开发基本都是使用框架了，react or Vue, 应该很少有用原生js来写的了。所以社区已经为我们提供了loader来和各种框架和库平滑地交互了。 React Hot Loader：实时调整 react 组件。 Vue Loader：此 loader 支持 vue 组件的 HMR，提供开箱即用体验。 Elm Hot Loader：支持 Elm 编程语言的 HMR。 Angular HMR：没有必要使用 loader！直接修改 NgModule 主文件就够了，它可以完全控制 HMR API。想了解更多的朋友，请戳 这里 二、Babel 处理 ES6官⽅⽹站：https://babeljs.io/中⽂⽹站：https://www.babeljs.cn/ 不了解babel的朋友，可以查看刘小夕小姐姐的这篇文章，《不容错过的 Babel7 知识》 Babel 是JavaScript 编译器，能将ES6代码转换成ES5代码，让我们开发过程中放⼼使⽤JS新特性⽽不⽤担⼼兼容性问题。并且还可以通过插件机制根据需求灵活的扩展。 Babel在执⾏编译的过程中，会从项⽬根⽬录下的 .babelrc ⽂件中读取配置。没有该⽂件会从loader的options 地⽅读取配置。 babel-loader安装依赖 1npm i babel-loader @babel/core @babel/preset-env -D @babel/core 是babel的核心，babel的功能都依靠它babel-loader 是 webpack 与 babel的通信桥梁，不会做把es6转成es5的⼯作，这部分⼯作需要⽤到@babel/preset-env 来做, @babel/preset-env⾥包含了es，6，7，8转es5的转换规则 12345678910&#123; test: /\\.js$/, exclude: /node_modules/, //排除node_modules中的文件 use: &#123; loader: \"babel-loader\", options: &#123; presets: [\"@babel/preset-env\"] &#125; &#125; &#125; 通过上面的方式，就可以把ES6+语法转换为ES5了。但是你可能会发现一个问题，假如你的代码中有promise，或者async/await,它并没有被转换，对于那些不支持promise的浏览器，这就是一个麻烦的地方了，这样我们又可以引出一个新的东西polyfill(垫片)，可以理解为ES6+的ECMA规范库 @babel/polyfill首先安装依赖，这个依赖并不是只有开发的时候需要使用，在生产的时候也需要使用 1npm i @babel/polyfill -S 然后在入口文件出引入这个文件,所有代码之前 1234//index.jsimport \"@babel/polyfill\"//... 与此同时，我们会遇到一个问题，这个库中我们又很多方法并没有使用到，把整个库都引入的话，会让我们的打包文件，体积增大很多。那我们需要解决这个问题，给垫片瘦身，实现按需加载，减少冗余。polyfill的初衷就是，我缺少什么，你就给我垫上。我们可以通过useBuiltIns字段来设置修改webpack.config.js 123456789101112131415options: &#123; presets: [ [\"@babel/preset-env\",&#123; targets: &#123; // edge: \"17\",配置浏览器的版本 // firefox: \"60\", // chrome: \"67\", // safari: \"11.1\" &#125;, corejs: 2,//新版本需要指定核⼼心库版本 useBuiltIns: \"entry\"//按需注⼊入 &#125; ] ] &#125; useBuiltIns 选项是babel 7 的新功能，这个选项告诉babel如何配置@babel/polyfill。它有三个参数可以使⽤用： entry: 需要在webpack的⼊口文件里import &quot;@babel/polyfill&quot;一次。babel会根据你的使用情况导⼊垫片，没有使用的功能不会被导⼊相应的垫片。 usage: 不需要import，全自动检测，但是要安装@babel/polyfill。（试验阶段） false: 如果你import&quot;@babel/polyfill&quot;，它不会排除掉没有使⽤的垫⽚片，程序体积会庞⼤大。(不推荐) 这个polyfill，有一个缺点就是，它会污染全局对象，因为都是直接挂在window上的，比如在开发UI组件的时候。 @babel/plugin-transform-runtime当我们开发的是组件库，⼯工具库这些场景的时候，polyfill就不不适合了了，因为polyfill是注⼊入到全局变量量，window下的，会污染全局环境，所以推荐闭包⽅方式：@babel/plugin-transform-runtime，它不不会造成全局污染 安装依赖 12npm i @babel/plugin-transform-runtime -Dnpm i @babel/runtime-corejs3 -S 修改配置⽂文件：注释掉之前的presets，添加plugins 1234567891011121314options: &#123; presets: [ [\"@babel/preset-env\",&#123; &#125; ] ], plugins: [ [\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 3, &#125; ] ] &#125; 它也是支持按需加载的，他不会造成全局污染，它不会挂载到window上，它通过替换的形式，假如缺少promise，他会创建一个_promise来替换。 更多配置，可以查看这里 @babel/preset-react我们 在开发react项目的时候，又是如何来解析jsx语法的呢??babel也为我们提供了一个插件 1npm i @babel/preset-react -D 在配置文件中加上 12345678options: &#123; presets: [ [\"@babel/preset-env\", //... ], [\"@babel/preset-react\"] ] &#125; 这个插件就是来做语法解析,这样我们就可以使用jsx语法开发react项目了。当然，如果你不想使用js文件，也可以创建jsx文件，把配置文件后缀名改为test: /\\.jsx$/就行了。 如果上面babel文件配置太多，会让js文件显得很庞大。所以我们可以把babel的配置移到它自己的配置文件里.babelrc。 三、Sourcemap源代码与打包后的代码的映射关系，通过sourceMap定位到源代码。在开发模式下，是默认开启sourcemap的，所以我们平时开发的时候，出现了错误，都会直接定位到源文件。那生产模式又是怎么配置的呢? 12345//webpack.config.jsmodule.exports = &#123; //... devtool: 'source-map'， //cheap-eval-source-map ...&#125; 开启这个选项之后，它会生成一个对应的 .map文件，里面表示打包文件和源代码的关系映射。 它还有很多可以其他可以选择的模式，每个模式的构建速度和结果不同，信息越详细，构建速度越慢，所以需要权衡这两个方面。如果想了解更多选项，请戳这里 生产环境是不建议开启sourcemap的，但是有一些特殊场景，比如要做错误解析，需要开启sourcemap的话，也不要把map文件上传到公网上，这样比较安全。 四、dev和prod模式 区分打包把所有配置都放在一个配置文件中，会显得很乱，不利于管理可读性很差，所以我们可以对不同环境做一下区分，在通过webpack-merge 来合并配置 三个配置文件 webpack.base.config.js 基础配置 webpack.dev.config.js 开发独有的配置 webpack.prod.config.js 生产独有的配置 安装这个插件 1npm i webpack-merge -D 配置文件 12345678//webpack.dev.config.jsconst merge = require('webpack-merge')const baseConfig = require(\"./webpack.base.config.js\")const devConfig = &#123; //...&#125;module.exports = merge(baseConfig,devConfig) 在package.json中配置脚本 12345\"scripts\":&#123; \"dev\":\"webpack-dev-server --config ./webpack.dev.config.js\", \"build\":\"webpack --config ./webpack.prod.config.js\"&#125; 之后执行 npm run dev或者npm run build 来分别打包了 基于环境变量区分平时我们在代码中，可能也需要针对生产或者是开发环境，做一些配置，那如何获取到当前的环境呢??? 安装 1npm i cross-env -D cross-env这个插件，是用来抹平各个操作系统之间的差异，比如windows和mac它们的使用路径的方式可能是不一样的 在package.json中设置 1\"dev\": \"cross-env NODE_ENV=dev webpack --config ./webpack.dev.config.js\", 那我们在代码中就可以拿到 1process.env.NODE_ENV //dev ————-如果以上内容有不对的地方，还请大家指正————","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.eyes487.top/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://blog.eyes487.top/tags/webpack/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"webpack深入学习（一）：基础配置篇","slug":"webpack-first","date":"2020-05-16T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/05/16/webpack-first.html","link":"","permalink":"http://blog.eyes487.top/2020/05/16/webpack-first.html","excerpt":"","text":"平时工作追求效率，一般都会使用脚手架，快速搭建项目，里面webpack都是帮我们配置好了的，导致我很少一段时间都是对webpack一知半解的。最近一段时间就深入了解了一下webpack，所以顺便把它记录下来，可能对其他人也会有点帮助，也方便自己之后回顾。 一、什么是webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 这是官网对webpack的一段解释,上面一张图是，通过webpack处理，把左边的(都可以看成是一个模块)，然后被处理成右边的这种形式。前端发展很快，出现了很多的新东西，但是浏览器对他们的支持又不是那么好，所以就需要webpack来打包构建等，把他们处理成浏览器支持的东西。 我们先看一下配置项主要会有哪些，先有个印象 123456789101112131415module.exports = &#123; entry: \"./src/index.js\", //打包⼊⼝⽂件 output: \"./dist\", //输出结构 mode: \"production\", //打包环境 module: &#123; rules: [ //loader模块处理 &#123; test: /\\.css$/, use: [\"style-loader\",\"css-loader\"] &#125; ] &#125;, plugins: [new HtmlWebpackPlugin()] //插件配置&#125; 二、安装webpack环境准备 node环境 推荐安装最近版本，node版本越高，webpack运行速度越快 不推荐全局安装 因为这会将项目找那个的webpack锁定到某个版本，造成不同的项目因为webpack依赖不同而导致冲突，构建失败。相信大家平时应该都不会去升级全局的版本 项目安装 推荐 1234567891011# 安装最新的稳定版本npm i -D webpack# 安装指定版本npm i -D webpack@&lt;version&gt;# 安装最新的体验版本 可能包含bug,不要⽤于⽣产环境npm i -D webpack@beta# 安装webpack V4+版本时，需要额外安装webpack-clinpm i -D webpack-cli 检查安装 123456webpack -v //command not found 默认在全局环境中查找npx webpack -v// npx帮助我们在项⽬中的node_modules⾥查找webpack./node_modules/.bin/webpack -v //到当前的node_modules模块⾥指定webpack 三、项目初始化下面，我们就通过项目来一步一步熟悉webpack的配置了 创建一个webpack-practice项目，然后通过npm init -y快速创建一个配置文件 1234mkdir webpack-practice &amp;&amp; cd webpack-practice &amp;&amp; npm init -y//安装webpacknpm install webpack webpack-cli -D //也可以使用yarn 我们可以通过npx webpack -v检测版本，npx是npm自带的，不用安装，这个命令会帮我们生成一个软连接，指向node_modules中的webpack，之后我们执行打包命令的时候，也会使用这个。 3.1 简单实例创建一个src/index.js 1console.log('hello world!!!!!!!!') 然后执行命令 npx webpack下面是打包之后输出的信息 此时，我们只是写了一个文件，并没有配置任何信息，这竟然也可以打包出来??? 这是因为，执行构建的时候，webpack会首先去找webpack.config.js,如果没有找到呢，它就会使用自己的默认配置信息。那默认配置信息长什么样呢，下面就来看一看 3.2 默认配置创建一个 webpack.config.js 123456789101112//webpack 是基于nodejs,所以得遵循common.js规范，导出一个对象const path = require('path')module.exports=&#123; //入口 entry: \"./src/index.js\", //默认打包入口 output: &#123; //构建的文件资源放在哪？必须是绝对路径 path: path.resolve(__dirname,\"./dist\"), //构建的文件资源叫啥？ filename: \"main.s\" &#125;&#125; 这就是webpack的默认配置了，webpack4⽀持零配置使⽤,但是很弱，稍微复杂些的场景都需要额外扩展，下面就来看看更多的配置吧 四、配置项4.1 mode大家是否有看到，上面打包输出，那张图上有一个warining,给出了一个警告大致意思是，必须设置一个mode，构建模式，没有设置，就会默认指定生产模式，所以代码会是压缩的它有下面这些值 这个值，你可以设置在config.js中，或者在打包的时候写入命令中npx webpack --mode=production 4.2 context 上下文这是一个不常用的配置，项目打包的相对路径 4.3 entry 入口 / output 出口三种类型：字符串、数组、对象 字符串已经说过了，就是上面那种格式，下面看看数组 新创建一个文件src/other.js 123456789module.exports=&#123; //入口 entry: [\"./src/index.js\", \"./src/other.js\"] output: &#123; path: path.resolve(__dirname,\"./dist\"), filename: \"index.js\" &#125; //...&#125; 打包完之后的信息依然只输出了一个文件，但是这个文件里包括了两个模块的代码，所以数组形式，是把多个mode打包到一个文件里面 多入口打包，对象形式，一旦有多入口的话，就会有多出口，所以这里不能指定名称，可以用到占位符,无论是一个出口还是多出口，都推荐使用占位符 占位符包括（常用）： name： 入口对应的名称 hash： 整个项目的hash，每次打包都会创建一个新的，不利于缓存，每次构建的唯一标识，可以指定长度，[hash:6] chunkHash： 根据不同入口entry进行依赖解析，构建对应的chunk，生成相应的hash，只要组成entry的模块没有内容改动，则对应的hash不变123456789101112module.exports=&#123; //入口 entry: &#123; index: \"./src/index.js\", other: \"./src/other.js\" &#125;, output: &#123; path: path.resolve(__dirname,\"./dist\"), filename: \"[name]-[chunkhash:6].js\" &#125; //...&#125; 下面是打包结果输出左边和右边对比，右边是修改了other.js之后的打包信息，可以看出，只有other.js文件的hash发生了改变，这样有利于浏览器缓存 这里，就借机提一下，bundle和chunk,这里是一个bundle对应一个chunk，bundle就是打包出来的文件，而chunk是代码块，它可以由多个模块组成，这是 webpack 特定的术语被用在内部来管理 building 过程。官网解释，请戳 这里 4.4 moduleWebpack 默认只⽀持.json 和 .js模块，不⽀持 不认识其他格式的模块，那么其他格式的模块处理，和处理⽅式就需要loader了 想了解更多，可以去 官网 查看,常见的loader有: 12345678910style-loadercss-loaderless-loadersass-loaderts-loader //将Ts转换成jsbabel-loader//转换ES6、7等js新特性语法file-loader//处理图⽚⼦图url-loadereslint-loader... 这些loader，基本都可以见名知义，看名字就知道是处理什么类型文件的。 4.4.1 处理样式style-loader css-loader首先安装依赖 1npm install style-loader css-loader -D 在js中引入css文件，比如 1234//index.cssbody&#123; background: red&#125; 12//index.jsimport 'index.css' 123456789101112131415161718//webpack.config.jsmodule.exports=&#123; //入口 entry:..., output: ..., module:&#123; rules:[ &#123; test: /\\.css$/, //css-loaser: 是把css模块的类型加入到js模块中区 css in js //style-loader: 从js中提取css，在html中创建style标签放入css //最好的设计就是，一个loader只做一件事情 use: [\"style-loader\",\"css-loader\"] &#125; ] &#125; //...&#125; 我们先说一下loader的工作流程：当webpack执行构建的时候，发现了它不认识的模块，然后它就会来module中查找，在rules中，通过后缀名的形式，配置了处理哪一类文件需要用到什么loader，loader的执行顺序是 从后往前,经过处理之后，webpack的构建过程就能顺利地执行下去了 执行打包命令，输出打包文件，我们可以先建一个index.html文件，引入刚才的打包成功的文件，就可以看到css效果了，（下面会讲到通过plugin自动引入打包文件,这里先自己创建一个) 从图上可以看到，css通过style标签引入html中了 less-loader上面说了css文件，但是我们项目开发一般都会选择，less或者sass，这又该怎么处理呢 安装依赖 1npm install less less-loader -D 12345678910111213141516//webpack.config.jsmodule.exports=&#123; //入口 entry:..., output: ..., module:&#123; rules:[ &#123; test: /\\.less$/, //less-loaser: 会把less转换为css文件 use: [\"style-loader\",\"css-loader\",\"less-loader\"] &#125; ] &#125; //...&#125; sass跟less处理方式差不多，这里就不说了 开启css-module我们在项目中使用css，一般都是通过css模块化的方式来使用的，也就是通过对象的形式来引入css 123456789101112131415161718192021222324//webpack.config.jsmodule.exports=&#123; //入口 entry:..., output: ..., module:&#123; rules:[ &#123; test: /\\.less$/, //less-loaser: 会把less转换为css文件 use: [\"style-loader\", &#123; loader: \"css-loader\", options: &#123; //css modules modules: true &#125; &#125;, \"less-loader\"] &#125; ] &#125; //...&#125; 下面是使用方式： postcss-loader它可以帮我们增加一些浏览器前缀，比如一些css的属性，在使用时都需要加上浏览器加上，而postcss-loader就是帮我们做这件事的 1npm install postcss-loader autoprefixer -D 1234567891011121314151617181920module:&#123; rules:[ &#123; test: /\\.less$/, //less-loaser: 会把less转换为css文件 use: [\"style-loader\", &#123; loader: \"css-loader\", options: &#123; //css modules modules: true &#125; &#125;, &#123; loader: \"postcss-loader\", &#125;, \"less-loader\"] &#125; ] &#125; 它要在css-loader之前使用，同时还需要创建一个postcss.config.js 12345678910const autoprefixer = require('autoprefixer')module.exports = &#123; plugins: [autoprefixer(&#123; //postcss 使用autoprefixer添加前缀的标准 //last 2 versions: 兼容最近的两个版本 //&gt;1%: 全球浏览器的时长份额大于1% //这两个属性基本可以覆盖普遍浏览器了 overrideBrowserslist: [\"last 2 versions\", \"&gt;1%\"] &#125;)]&#125; 效果图 4.4.2 处理图片和文字file-loader安装依赖 1npm install file-loader -D 123456789101112131415module:&#123; rules:[ //... &#123; test: /\\.(png|jpe?g|gif)$/, use: &#123; loader: \"file-loader\", options: &#123; name: \"[name]-[hash:6].[ext]\", outputPath: \"images/\" &#125; &#125;, &#125; ] &#125; 首先在test中配置图片后缀名，打包的图片文件同样也支持占位符，还有ext表示后缀名， output是打包图片输出的目录，统一放在images下 同时，这个loader还可以用来处理文字，比如我们经常都会使用到的字体图标,在阿里图标中下载几个图标，把woff2文件放入assets文件下，可以自己随意放在哪里 1234567891011//webpack.cofig.js&#123; test: /\\.(eot|ttf|woff|woff2|svg)$/, use: &#123; loader:\"file-loader\", options: &#123; name: \"[name]-[hash:6].[ext]\", &#125; &#125;, &#125; 1234567891011//css@font-face &#123; font-family: \"iconfont\"; font-display: swap; src: url(\"assets/iconfont.woff2\") format(\"woff2\")&#125;.iconfont &#123; font-family: \"iconfont\" !important; font-size: 30px; font-style: normal;&#125; 在页面中引用 12345678//index.jsimport styles from './index.less'let ele = `&lt;div class=\"$&#123;styles.iconfont&#125;\"&gt;&amp;#xe64d;&lt;/div&gt;&lt;div class=\"$&#123;styles.iconfont&#125;\"&gt;&amp;#xe652;&lt;/div&gt;&lt;div class=\"$&#123;styles.iconfont&#125;\"&gt;&amp;#xe64e;&lt;/div&gt;`document.write(ele) 效果展示： url-loader这是file-loader的加强版，它包含了file-loader的全部功能,推荐使用url-laoder,这是因为它会支持limit 12345678910111213//webpack.cofig.js&#123; test: /\\.(png|jpe?g|gif)$/, use: &#123; loader:\"url-loader\", options: &#123; name: \"[name]-[hash:6].[ext]\", outputPath: \"images/\", limit: 1024, //单位是字节 1024=1kb &#125; &#125;, &#125; 上面limit的意思是，当图片小于1kb的时候，会把图片转为base64格式,直接插入代码中，这样就可以减少一些请求，大于1kb就会打包成图片放在images文件夹下。这个具体大小，就看大家怎么衡量了，自己可以设置。一般都推荐小体积的图片资源就转为base64格式 4.5 plugins插件，它是webpack的一个补充，可以运行在webpack的整个打包过程，每个plugin，都是针对webpack的一个生命周期，做操作的 clean-webpack-plugin我们上面打包了很多次，然后在dist目录下，生成了很多冗余文件，所以我们需要一个插件来帮我清理掉这些文件 1npm install clean-webpack-plugin -D 1234567891011const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin')module.exports=&#123; //入口 entry:..., output: ..., module:..., plugins: [ new CleanWebpackPlugin() ] //...&#125; 这样，它重新打包的时候，就会帮我们清理掉上次打包的文件了。 html-webpack-plugin上面也说到了，我们需要一个plugin来帮我们自动引用打包文件，不用每次自己创建html，在引用打包的js了。 首先创建一个src/index.html 安装依赖 1npm install html-webpack-plugin -D 12345678const HtmlWebpackPlugin = require('html-Webpack-Plugin')// ...plugins:[ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html' &#125;) ] 这样在打包的时候，就可以把index.html也打包进dist目录，并且引用打包的js文件了它还有很多其他的配置项，这里就不一一列举了，感兴趣的可以自己试一下，戳这里 上面做了一个webpack的最基本配置，算是对webpack的一些基本了解。下一篇会拓展一些项目中用到的其他配置 ————-如果以上内容有不对的地方，还请大家指正————","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.eyes487.top/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://blog.eyes487.top/tags/webpack/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"react-redux 简单实现","slug":"achieve-react-redux","date":"2020-03-07T00:00:00.000Z","updated":"2020-07-23T12:22:45.189Z","comments":true,"path":"2020/03/07/achieve-react-redux.html","link":"","permalink":"http://blog.eyes487.top/2020/03/07/achieve-react-redux.html","excerpt":"","text":"要想在react中使用redux，通过react-redux会方便很多，今天就来看看react-redux究竟是如何实现的吧。 react-redux有两个核心关键模块: Provider 和 connect 1. react-redux用法在根组件外面套一层Provider，使组件层级中都能获得store，store就是通过redux创建的。 123456ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); 在具体组件中通过connect获取redux store 1234567891011121314151617181920export default connect( //mapStateToProps (state) =&gt; &#123; return (&#123;count: state&#125;) &#125;, //mapDispatchToProps 可以是对象或者函数 // &#123; // add: ()=&gt;(&#123;type: 'ADD'&#125;), // &#125;, dispatch=&gt;&#123; let res = &#123; add: ()=&gt;(&#123;type: 'ADD'&#125;), &#125; res = bindActionCreators(res,dispatch) return &#123; dispatch, ...res &#125; &#125;)(Component); connect想当于一个高阶组件，接收一个组件，返回一个新的组件。connect接受四个不同的参数，均为可选参数，但是一般最常用的是mapStateToProps和mapDispatchToProps,下面只看这两个参数的写法通过上面这种方式，redux store就注入到组件中了，就可以在this.props中取到了 下面就看看Provider 和 connect 是怎么实现的吧 2. Provider实现Provider向下面的子组件提供store，那下面的子组件如何跨层取得数据呢，这就要用到Context了，如果不了解context的朋友，请点击这里 1234567891011//创建一个Contextconst ValueContext = React.createContext();export class Provider extends Component &#123; render() &#123; //通过Provider提供下去 return &lt;ValueContext.Provider value=&#123;this.props.store&#125;&gt; &#123;this.props.children&#125; &lt;/ValueContext.Provider&gt; &#125;&#125; 通过React.createContext创建一个Context 通过ValueContext.Provider提供给子组件 显示 children 3. connect实现connect 会接收几个参数，主要实现mapStateToProps和mapDispatchToProps 创建connect函数，接收参数会返回一个新的函数，这个函数接收组件，返回新的组件 12345678export const connect = (mapStateToProps, mapDispatchToProps,) =&gt; WrapperComponent=&gt; &#123; return class extends Component&#123; render()&#123; return &lt;WrapperComponent/&gt; &#125; &#125;&#125; 在这函数里面，要想拿到父组件传递过来的redux store，可以通过contextType获取 123456789101112export const connect = (mapStateToProps, mapDispatchToProps,) =&gt; WrapperComponent=&gt; &#123; return class extends Component&#123; static contextType = ValueContext; //上面provider处创建的context state= &#123; &#125; render()&#123; console.log('this.context',this.context)//可以打印看看这时context已经有了 return &lt;WrapperComponent/&gt; &#125; &#125;&#125; 下面实现mapStateToProps,在connect函数的class中 1234567891011componentDidMount()&#123; const &#123;getState&#125; = this.context; let stateProps = mapStateToProps(getState()); this.setState(&#123; props: &#123; ...stateProps &#125; &#125;)&#125; this.context 就是redux store，所以直接拿到getState，就可以获取state的值 mapStateToProps 是一个会接收到state的参数，返回新的对象的一个函数 this.setState可以让页面重新更新，所有使用它，来给props赋值，之后把这个props传入组件中 1return &lt;WrapperComponent &#123;...this.state.props&#125;/&gt; 下面实现mapDispatchToProps,在connect函数的class中,它或有两种形式，对象或者是函数 12345678910111213141516const &#123;dispatch&#125; = this.context;let dispatchProps;if(typeof mapDispatchToProps === 'object')&#123; dispatchProps = bindActionCreators(mapDispatchToProps,dispatch)&#125;else if(typeof mapDispatchToProps === 'function')&#123; dispatchProps = mapDispatchToProps(dispatch)&#125;else&#123; dispatchProps = &#123;dispatch&#125;;&#125;this.setState(&#123; props: &#123; ...dispatchProps &#125; &#125;) 从this.context中拿到dispatch 判断，如果传入的是对象，就给他包一层dispatch，就可以直接作为请求参数了,bindActionCreators是redux中提供的一个函数，下面 会写到它的实现原理 如果传入的函数，就一直作为函数返回，它会接收dispatch作为参数 默认，什么都不传的时候，就把dispatch返回回去 之后把这个dispatchProps参数放入props，就可以传递给组件了 bindActionCreators是redux中给提供的方法，只是函数包一层dispatch 1234567891011121314151617function bindActionCreators(actionCreators, dispatch) &#123; var boundActionCreators = &#123;&#125;; for (var key in actionCreators) &#123; var actionCreator = actionCreators[key]; if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch); &#125; &#125; return boundActionCreators;&#125;function bindActionCreator(actionCreator, dispatch) &#123; return function () &#123; return dispatch(actionCreator.apply(this, arguments)); &#125;; &#125; 为了在使用dispatch改变数据之后，页面能够重新渲染，所以还需要使用subscribe订阅，用来监听数据改变，让页面发生变化。 好了，下面看看完整代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import React, &#123; Component &#125; from 'react'const ValueContext = React.createContext();export const connect = (mapStateToProps, mapDispatchToProps, mergeProps) =&gt; WrapperComponent=&gt; &#123; return class extends Component&#123; static contextType = ValueContext; state =&#123; props: &#123;&#125; &#125; componentDidMount()&#123; const &#123;subscribe&#125; = this.context; this.update() subscribe(this.update) &#125; update =()=&gt;&#123; const &#123;dispatch,getState&#125; = this.context; let stateProps = mapStateToProps(getState()); let dispatchProps ; if(typeof mapDispatchToProps === 'object')&#123; dispatchProps = bindActionCreators(mapDispatchToProps,dispatch) &#125;else if(typeof mapDispatchToProps === 'function')&#123; dispatchProps = mapDispatchToProps(dispatch) &#125;else&#123; dispatchProps = &#123;dispatch&#125;; &#125; this.setState(&#123; props: &#123; ...dispatchProps, ...stateProps, &#125; &#125;) &#125; render()&#123; console.log('this.context',this.context); return &lt;WrapperComponent &#123;...this.state.props&#125;/&gt; &#125; &#125;&#125;export class Provider extends Component &#123; render() &#123; return &lt;ValueContext.Provider value=&#123;this.props.store&#125;&gt; &#123;this.props.children&#125; &lt;/ValueContext.Provider&gt; &#125;&#125;function bindActionCreators(actionCreators, dispatch) &#123; var boundActionCreators = &#123;&#125;; for (var key in actionCreators) &#123; var actionCreator = actionCreators[key]; if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch); &#125; &#125; return boundActionCreators;&#125;function bindActionCreator(actionCreator, dispatch) &#123; return function () &#123; return dispatch(actionCreator.apply(this, arguments)); &#125;; &#125; 这差不多就实现了一个简单的react-redux了。 源码地址 ————-如果以上内容有不对的地方，还请大家指正————","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"react-redux redux","slug":"react-redux-redux","permalink":"http://blog.eyes487.top/tags/react-redux-redux/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"redux 简单实现","slug":"achieve-redux","date":"2020-02-26T00:00:00.000Z","updated":"2020-07-23T12:22:45.189Z","comments":true,"path":"2020/02/26/achieve-redux.html","link":"","permalink":"http://blog.eyes487.top/2020/02/26/achieve-redux.html","excerpt":"","text":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 除了和 React 一起用外，还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。 1. redux用法三大原则 单一数据源: 整个应用的 state 只存在于唯一一个 store 中 State 是只读的: 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改: 描述 action 如何改变 state tree,都编写在reducer中 上面是redux工作流的图解。store中存放数据，数据发生变化，通知页面更新。页面上想要修改数据，就会派发一些指令，通过dispatch发送action 给 store，store就会去查阅Reducers，在Reducers中定义了修改数据的方式，接收之前的state和action,返回新的state。 下面回顾一下redux的用法:定义reducer函数 1234567891011121314151617const initState = &#123;a: 1,b: 3&#125;function counterReducer(state = initState,action)&#123; const &#123;type,payload&#125; = action; switch(type)&#123; case \"ADD\": let a = state.a + payload; return &#123;...state,a&#125;; case \"MINUS\": let b = state.b - payload; return &#123;...state,b&#125;; default: return state; &#125;&#125;//通过createStore创建唯一数据源const store = createStore(counterReducer); 在页面上通过dispatch,发送action更改数据 1store.dispatch(&#123; type:'ADD', payload:5 &#125;); 通过subscribe订阅更新函数 1234// 数据更新之后会执行订阅的回调函数store.subscribe(()=&gt;&#123; //更新&#125;); 2. redux实现下面我们就来实现一个简单的redux 2.1 CreateStoreredux的几个核心函数， getState,dispatch ,subscribe 首先创建CreateStore函数 1234567891011121314151617181920212223242526272829303132export function createStore(reducer)&#123; //创建state，统一储存数据 let state = undefined; //监听器数组 let listenerMap = []; //getState():直接返回数据state function getState()&#123; return state; &#125; //dispatch: 执行action，会去reducer中查阅action执行，返回新的state //数据更新之后，监听器中存储的回调函数会被执行 function dispatch(action)&#123; state = reducer(state,action) listenerMap.map(listener=&gt;listener()) &#125; //subscribe: 订阅函数，把传入的回调函数，放入监听数组中 function subscribe(listener)&#123; listenerMap.push(listener) &#125; //初始化数据，会走到default，直接返回state dispatch(&#123;type: 'INIT'&#125;) return &#123; getState, dispatch, subscribe &#125;&#125; 首先，会定义state，用来存储所有的数据 listenerMap 监听器数组，存放回调函数，方便之后数据更新之后执行回调 getState() 直接返回数据state dispatch 会传入action，要执行的操作，定义的规则都放在reducer中，然后就会查阅reducer，执行具体方法，然后返回state，数据更新之后，执行监听器中的回调函数 subscribe 订阅函数，把传入的回调函数，放入监听数组中 dispatch({type: &#39;INIT&#39;}) 通过自己定义的规则，初始化数据，不直接通过外面给初始值，这样更严谨 2.2 combineReducers有时候数据太多，需要拆分成多个reducer,所以redux中还提供了一个combineReducers函数，用来把Reducer 合成一个。使用方法 12const reducers = combineReducers(&#123;reducerA, reducerB&#125;)const store = createStore(reducers); 实现方法 12345678910111213141516export function combineReducers(reducers)&#123; let combineReducers = &#123;...reducers&#125;; //复制一份新的 let keys = Object.keys(combineReducers); return function combination(state = &#123;&#125;,action)&#123; let hasChanged = false; const nextState = &#123;&#125;; keys.forEach(key=&gt;&#123; const previousStateKey = state[key]; const nextStateKey = combineReducers[key](previousStateKey, action) nextState[key] = nextStateKey; hasChanged = hasChanged || nextStateKey !== previousStateKey &#125;) return hasChanged? nextState : state &#125;&#125; 复制一份新的传入的reducers，防止数据污染 聚合reducers之后，还是会返回一个函数，它接受的参数就和之前reducer一样 定义一个变量，记录state是否改变，初始值为false 循环这个对象中的keys值，获取到每个reducer对应的上一次的state值，保存到变量previousStateKey 通过当前reducer生成下一次的state，保存在nextStateKey 判断两次state的值是否相等，改变hasChanged变量 最后则是根据hasChanged来返回state，如果没有变化则返回原来的state。如果有变化则返回nextState。 2.3 applyMiddleware官网描述 默认情况下，createStore() 所创建的 Redux store 没有使用 middleware，所以只支持 同步数据流。你可以使用 applyMiddleware() 来增强 createStore()。虽然这不是必须的，但是它可以帮助你用简便的方式来描述异步的 action。 applyMiddleware用法 12//thunk:redux-thunk 用来做异步操作const store = createStore(reducer,applyMiddleware(thunk,middlewareA,middlewareB)); 在页面中就可以这样使用了 1234567asyncAdd =()=&gt;&#123; store.dispatch(dispatch=&gt;&#123; setTimeout(()=&gt;&#123; dispatch(&#123;type: 'ADD'&#125;) &#125;,1000) &#125;)&#125; store.dispatch可以执行异步操作了，但是还是会返回dispatch，所以applyMiddleware的作用就是对所有中间件封装了一层，然后还是会返回store，store中会有dispatch 下面看具体实现在createStore中 1234567891011export function createStore(reducer, enhancer)&#123; if(enhancer)&#123; return enhancer(createStore)(reducer) &#125; //...... return &#123; getState, dispatch, subscribe &#125;&#125; enhancer,加强createStore函数，然后返回一个函数，接受reducer，还是和之前一样 下面看看applyMiddleware的具体实现方法 12345678910111213141516171819202122232425262728293031323334export function applyMiddleware(...middlewares)&#123; //middlewares 中间件数组,接收中间件，然后会返回一个函数，相当于上文中的enhancer //enhaner会接收 createStore 参数， 返回一个函数 //这个函数 ，接收reducer，执行原来createStore该做的操作， return createStore =&gt; (...args)=&gt;&#123; //创建store， 里面就有getState ，dispatch 等 const store = createStore(...args); const middleApi = &#123; getState: store.getState, dispatch: store.dispatch &#125; //middlewares 传入的中间件数组，将middleApi传入，会返回一个新的函数数组 const middlewareChain = middlewares.map(middleware=&gt; middleware(middleApi) ) //通过把原始的dispatch，经过所有的中间件增强之后返回一个新的增加版dispatch，就可以做比如异步操作之类的了 const dispatch = compose(...middlewareChain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125;// 聚合函数 将上一个执行函数的返回值 ，传递给下一个参数function compose(...funcs)&#123; return funcs.reduce((a,b)=&gt;&#123; return (...args)=&gt;&#123; return a(b(...args)) &#125; &#125;)&#125; 源码地址 ————-如果以上内容有不对的地方，还请大家指正————","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"redux","slug":"redux","permalink":"http://blog.eyes487.top/tags/redux/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（五）：虚拟dom和diff算法","slug":"vue-sourcec-analyse-05","date":"2020-01-30T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/01/30/vue-sourcec-analyse-05.html","link":"","permalink":"http://blog.eyes487.top/2020/01/30/vue-sourcec-analyse-05.html","excerpt":"","text":"在Vue2中，数据响应式和虚拟DOM是分不开，它们是Vue的核心。Vue2中是一个组件一个Watcher实例，假如数据变化了，只能通知组件更新，这时就需要用到虚拟DOM和diff算法对比得出差异更新真实DOM了。 Vue版本: 2.6.11 1. 虚拟DOM虚拟DOM(Virtual DOM)是对DOM的js抽象表示，他们是js对象，能描述DOM结构和关系，应用的各种状态变化会作用于虚拟DOM，最终映射到真实DOM上。因为是纯粹的js对象，所以操作起来就很高效。页面渲染的时候生成vdom，数据更新会生成一个新的vdom，新的vdom和老的vdom进行比较，这个过程称为diff算法，得出差异，应用在真实dom上。 Vue的diff算法是基于snabbdom算法所做的修改，感兴趣的朋友可以自己去查看。 下面从源码中去分析vue中的vdom是如何工作的。 2. 渲染和更新流程首先，我们要找到，vm实例挂载的$mount会调用mountComponent函数(第二篇文章有说过)，看看这个函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445//src/core/instance/lifecycle.jsexport function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode // ... &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // ... &#125; &#125; else &#123; //用户$mount时，定义updateComponent updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; //我们将其设置为观察者构造函数中的vm._watcher //因为观察者的初始补丁可能会调用$ forceUpdate（例如，在child内部 //组件的挂接钩），它依赖于已定义的vm._watcher new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; 用户在$mount时，定义updateComponent函数 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 下面 new Watcher把刚才定义的更新函数传进去了 1234567new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125;&#125;, true /* isRenderWatcher */) 如果watcher执行run方法，就会调用传入的回调，也就是updateComponent而updatemount中需要执行_render方法,返回vdom，其中也就是给vdom额外的加了一些vue的属性，把返回的vdom作为_update的第一个参数，然后执行_update方法 那看看_update方法是如何工作的 12345678910111213141516171819202122232425262728293031//src/core/instance/lifecycle.jsVue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // 初始渲染 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 更新 vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. &#125; 在这里面，我们发现vm.__patch__方法，上面是初始化渲染，只要传入宿主元素和vdom就行，下面是更新，需要传入老的vdom和新的vdom。看看patch都做了什么,在src/core/vdom/patch.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788return function patch (oldVnode, vnode, hydrating, removeOnly) &#123; //判断是否有新的虚拟dom， 没有就删除 if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] //是否有老的节点 1.初始化的时候，有传入$el, 2.更新，传入oldVnode if (isUndef(oldVnode)) &#123; // empty mount (likely as component), create new root element isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; //是否是真正的dom const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node //更新的时候，真正的diff算法 patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; //真实dom，就是初始化渲染 if (isRealElement) &#123; //... // 创建一个空节点并替换它 oldVnode = emptyNodeAt(oldVnode) &#125; // replacing existing element const oldElm = oldVnode.elm //当前宿主元素 const parentElm = nodeOps.parentNode(oldElm) //即body，之后把新创建的真实dom追加进body，然后在删除之前的节点 // create new node //根据虚拟dom创建真实dom createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // update parent placeholder node element, recursively if (isDef(vnode.parent)) &#123; let ancestor = vnode.parent const patchable = isPatchable(vnode) while (ancestor) &#123; for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123; cbs.destroy[i](ancestor) &#125; ancestor.elm = vnode.elm if (patchable) &#123; for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, ancestor) &#125; // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the \"inserted\" hook. const insert = ancestor.data.hook.insert if (insert.merged) &#123; // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) &#123; insert.fns[i]() &#125; &#125; &#125; else &#123; registerRef(ancestor) &#125; ancestor = ancestor.parent &#125; &#125; // 删除旧节点 if (isDef(parentElm)) &#123; removeVnodes([oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; invokeDestroyHook(oldVnode) &#125; &#125; &#125; invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm &#125; 首先会做一系列的判断，老节点和新节点的判断，更新操作,会执行patchVnode方法，初始化渲染，会根据虚拟dom生成真实dom追加在宿主元素的父节点中，然后在删除旧的节点。 下面看个例子 1234&lt;div id=\"demo\"&gt; &lt;p&gt;虚拟dom&lt;/p&gt; &#123;&#123;obj.foo&#125;&#125;&lt;/div&gt; 12345678const app = new Vue(&#123; el: '#demo', data:&#123; obj:&#123; foo:'hello world' &#125; &#125;,&#125;) 执行结果 3. diff算法 这是一张很经典的图，出自《React’s diff algorithm》，Vue的diff算法也同样，即仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。那同级vnode diff的细节又是怎样的呢？ 3.1 sameVnode1234567891011121314151617//src\\core\\vdom\\patch.jsfunction sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; ( // key值 ( a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 isDef(a.data) === isDef(b.data) &amp;&amp; // 是否都定义了data，data包含一些具体信息，例如onclick , style sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; 在执行patchVnode之前会执行sameVnode判断，新老节点是否是否是同类型节点，值得进行patchVnode 3.2 patchVnode先总结一下其中的规则，比较两个vnode，包括三种类型操作：属性更新，文本更新，子节点更新具体规则如下： 新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren 如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点 当新节点没有子节点而老节点有子节点的时候，则先移除该节点的所有子节点 当新老节点都无子节点的时候，只是文本替换 那我们先看看patchVnode都做了什么里面会有优化操作，比如isAsyncPlaceholder,isStatic,是否是占位符，静态节点，就不用了做diff了 123456789101112131415161718192021222324252627//src\\core\\vdom\\patch.js//判断是否是元素if (isUndef(vnode.text)) &#123; //没有文本就是元素 //双方都有孩子 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; //比孩子，重排 if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; //新节点存在 if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(ch) &#125; //清空老节点文本 if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') // 创建孩子并追加 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; //老节点有孩子，直接删除即可 removeVnodes(oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; //老节点存在文本，清空 nodeOps.setTextContent(elm, '') &#125;&#125; else if (oldVnode.text !== vnode.text) &#123; //双方都是文本节点，更新 nodeOps.setTextContent(elm, vnode.text)&#125; 这里面最主要的就是重排算法updateChildren，下面看看里面究竟是如何工作的 3.3 updateChildren推荐一篇文章，用例子讲解的很详细， 比较两棵树最直接的方法就是双循环了，Vue中针对web场景做了特殊的优化方式。很多情况下我们都是在前面或者后面去追加节点，或者就是升序或者降序排列，那大概率的就是前面和后面的比较。有一个高效的方式，就是给不同节点设置key，就可以快速找到节点，进行判断是不是相同节点。 Vue中就是在新老两组vdom节点的左右两头设置了两对指针，在遍历的过程中，这几个指针都会向中间靠拢，当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。处理过的节点Vue会在oldVdom和newVdom中同时将它标记为已处理。 下面看遍历规则 优先处理的情况 头部的同类型节点、尾部的同类型节点, 这类节点更新前后位置没有发生变化，所以不用移动它们对应的DOM 头尾/尾头的同类型节点, 这类节点位置很明确，不需要再花心思查找，直接移动DOM就好 原地复用是Vue会尽可能的复用节点，不发生dom的移动。如果两个节点时同类节点(比如：div),那么Vue会直接复用DOM，这样的好处是不需要移动,但是也会产生一些问题。 整个过程是逐步找到更新前后vdom的差异，然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM（React则是将更新放入队列后集中处理），朋友们会问这样做性能很差吧？实际上现代浏览器对这样的DOM操作做了优化，并无差别。 先看看代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//src\\core\\vdom\\patch.js//循环条件：开始索引不能大于结束索引while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right //老的开始和新的结束节点相同，除了打补丁之外，向后移动 patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; //4中猜想之后没有找到相同的，不得不开始循环查找 if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element //没找到则创建新元素 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; //找到除了打补丁，还要移动到对首 vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125;&#125;//整理工作，必定有数组还剩下的元素未处理if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)&#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(oldCh, oldStartIdx, oldEndIdx)&#125; 首先，当 oldStartVnode 和 newStartVnode 或者 oldEndVnode和newEndVnode 满足同类节点，直接将该VNode节点进行patchVnode即可，深层次比较，节点相同的两个指针向中间移动一个，不需再遍历就完成了一次循环。如下图， 如果oldStartVnode与newEndVnode满足同类节点。说明oldStartVnode已经跑到了oldEndVnode后面去了，进行patchVnode的同时还需要将真实DOM节点移动到oldEndVnode的后面。这两个指针向中间移动一格。 如果oldEndVnode与newStartVnode满足同类节点，说明oldEndVnode跑到了oldStartVnode的前面，进行patchVnode的同时要将oldEndVnode对应DOM移动到oldStartVnode对应DOM的前面。这两个指针向中间移动一格。 如果以上情况均不符合，则在old VNode中找与newStartVnode满足同类节点的vnodeToMove，如果找到了，就执行patchVnode，同时将vnodeToMove对应DOM移动到oldStartVnode对应的DOM的前面，newStartVnode向后移一格，但是在oldVnode中该节点处没有指针，所以就不能移动，只能该老节点标记一下说明它已经处理过了，设置为undefined 当然也有可能newStartVnode在old VNode节点中找不到一致的key，或者是即便key相同却不是同类节点，这个时候会调用createElm创建一个新的DOM节点。 至此循环结束，但是我们还需要处理剩下的节点。 当结束时oldStartIdx &gt; oldEndIdx，这个时候旧的VNode节点已经遍历完了，但是新的节点还没有。说明了新的VNode节点实际上比老VNode节点多，需要将剩下的VNode对应的DOM插入到真实DOM中，此时调用addVnodes（批量调用createElm接口）。 但是，当结束时newStartIdx &gt; newEndIdx时，说明新的VNode节点已经遍历完了，但是老的节点还有剩余，需要从文档中的节点删除。 至此，整个diff算法就结束了。 ————-如果以上内容有不对的地方，还请大家指正———— 参考链接：深入Vue2.x的虚拟DOM diff原理Vue 虚拟DOM和Diff算法 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》《Vue源码解析（四）：Vue批量异步更新策略》《Vue源码解析（五）：虚拟dom和diff算法》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://blog.eyes487.top/tags/虚拟DOM/"},{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（四）：Vue批量异步更新策略","slug":"vue-sourcec-analyse-04","date":"2020-01-29T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/01/29/vue-sourcec-analyse-04.html","link":"","permalink":"http://blog.eyes487.top/2020/01/29/vue-sourcec-analyse-04.html","excerpt":"","text":"Vue页面中会存在多个组件，每个组件对应着一个Watcher，当页面中多个组件发生变化的时候，最好的办法就是把组件批量的更新，然后在一次性刷新页面，这样效率极高。这样想到了用微任务,会在同一次事件循环(tick)中执行完，然后在刷新页面。要了解这个知识点，首先需要了解一下事件循环，如果不了解可以先看看这篇文章《理解浏览器和Node中的事件循环(EventLoop)》 Vue版本: 2.6.11 1.实例先看一个实例 123&lt;div id=\"demo\"&gt; &lt;p id=\"num\"&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112const app = new Vue(&#123; el: '#demo', data:&#123; count: 0, &#125;, mounted()&#123; setTimeout(()=&gt;&#123; this.count++; console.log(num.innerHTML) //0 &#125;,3000) &#125;&#125;) 可以看出count重新赋值后并不是马上刷新页面的，所以dom的更新是异步的。 2.Vue中的实现下面是Vue官方文档中对异步更新队列的说明 可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 异步： 只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 批量： 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 异步策略: Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 下面就通过源码来看一下，是如何实现的。 2.1 Watcher队列数据变化触发更新是通过dep.notify()然后会去调用watcher的update方法 12345678910111213//observer/watcher.jsupdate () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) &#125;&#125; 其中有一些配置，比如lazy、sync，但是一般都不会设置，最主要的是queueWatcher，把左右Watcher添加进一个观察者对列,下面看看它的具体实现代码 1234567891011121314151617181920212223242526272829303132//observer/scheduler.jsexport function queueWatcher (watcher: Watcher) &#123; const id = watcher.id // 去重，不存在才入队 if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; queue.push(watcher) &#125; else &#123; //如果已经刷新，则根据其ID拼接观察者 //如果已经超过其ID，它将立即立即运行。 let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush //waiting变量，这是很重要的一个标志位，它保证flushSchedulerQueue回调只允许被置入callbacks一次。 if (!waiting) &#123; waiting = true if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; flushSchedulerQueue() return &#125; // 异步刷新队列 nextTick(flushSchedulerQueue) &#125; &#125;&#125; 每个watcher都有一个id，要判断id是否存在于对列中，如果存在就不用入队了，有效地防止重复操作，然后执行nextTick,异步刷新对列，flushSchedulerQueue是一个函数，作用是循环执行queue中Watcher的run函数，用来更新视图,作为回调函数传入nextTick看看它的具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//observer/scheduler.js// nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchersfunction flushSchedulerQueue () &#123; currentFlushTimestamp = getNow() flushing = true let watcher, id /* 给queue排序，这样做可以保证： 1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。 2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建 3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。 */ queue.sort((a, b) =&gt; a.id - b.id) /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/ for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id /*将has的标记删除*/ has[id] = null /*执行watcher*/ watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"$&#123;watcher.expression&#125;\"` : `in a component render function.` ), watcher.vm ) break &#125; &#125; &#125; // keep copies of post queues before resetting state /*得到队列的拷贝*/ const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() /*重置调度者的状态*/ resetSchedulerState() // call component updated and activated hooks /*使子组件状态都改编成active同时调用activated钩子*/ callActivatedHooks(activatedQueue) /*调用updated钩子*/ callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) &#123; devtools.emit('flush') &#125;&#125; 2.2 nextTick12345678910111213141516171819202122232425262728//core/util/next-tick.jsexport function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve //把回调函数放入一个对列中 callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) //pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次 if (!pending) &#123; pending = true // 异步函数 timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 这里主要是，把回调函数放入callbacks对列中，执行异步函数timerFunc() 2.3 timerFunc看看timerFunc都做了哪些事情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//core/util/next-tick.jsif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; // 启动一个微任务 p.then(flushCallbacks) //在有问题的UIWebViews中，Promise.then不会完全中断，但是 //它可能会陷入怪异的状态，在这种状态下，回调被推入 //微任务队列，但是直到浏览器才刷新队列 //需要做一些其他工作，例如处理一个计时器。因此，我们可以 //通过添加空计时器来“强制”刷新微任务队列。 if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; //在本地Promise不可用的地方使用MutationObserver， //例如PhantomJS，iOS7，Android 4.4 //（＃6466 MutationObserver在IE11中不可靠） let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; //回退到setImmediate。 //从技术上讲，它利用了（宏）任务队列， //，但它仍然是比setTimeout更好的选择。 timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 在这个函数中，它会判断，看浏览器是否支持Promise，就启动一个微任务执行flushCallbacks，不支持就会做降级处理，主要是考虑到浏览器兼容性，按照Promise、MutationObserver、setImmediate、setTimeout这样的顺序，前两个是微任务，后两个是宏任务，微任务是首选，最后不得已要使用宏任务。我们知道微任务会在页面刷新之前执行完，使用微任务就可以比使用宏任务少执行一次UI 渲染 2.4 flushCallbacks刷新的回调函数，这里才是真正执行刷新的地方 123456789//core/util/next-tick.jsfunction flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 会把之前callbacks队列中存放的所有回调函数全部取出来执行一遍，也就完成了整个刷新过程。 一直都知道，尽可能少的操作Dom，Vue批量异步更新也是如何，把所有要更新的数据都更新完了，在一次性刷新页面，这样效率是极高的，所以异步更新视图是极有必要的。 参考链接：https://github.com/answershuto…https://segmentfault.com/a… 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》《Vue源码解析（四）：Vue批量异步更新策略》《Vue源码解析（五）：虚拟dom和diff算法》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（三）：数据响应式","slug":"vue-sourcec-analyse-03","date":"2020-01-28T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/01/28/vue-sourcec-analyse-03.html","link":"","permalink":"http://blog.eyes487.top/2020/01/28/vue-sourcec-analyse-03.html","excerpt":"","text":"Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。 之前写过一篇文章《实现MVVM原理》,今天从源码的角度了解一下数据响应式是如何实现的。在上一篇文章 initState 处就是做数据响应式的，今天就从这里开始。 Vue版本: 2.6.11 1.initState()src/core/instance/state.js中 1234567891011121314151617 export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 属性初始化 if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) // 数据响应式====&gt;从这进入 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 在里面做了一系列数据的初始化，包括props，methods，但是最重要的是data一般用户都会定义data，然后对data做数据响应式，就进入到 initData 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// src/core/instance/state.js中function initData (vm: Component) &#123; // 把数据从options中取出来 let data = vm.$options.data //对data的定义可是函数也可以是对象 data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance // 代理这些数据到实例上，通过实例就可以直接访问到数据 const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] //这上面做的是一些判重 if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 主要代码--代理 proxy(vm, `_data`, key) &#125; &#125; // observe data // 响应式操作 observe(data, true /* asRootData */)&#125; 这个文件中就是获取data，设置代理，启动响应式observe 2.Observer所有数据响应式的代码都在 observer 文件夹下,MVVM框架最重要的就是数据响应式了 123456789101112131415161718192021222324// src/core/observer/index.jsexport function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; // 观察者，已经存在直接返回，否则创建新的实例 let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 这个方法，主要是判断是否存在(ob属性），如果存在就直接返回，如果不存在就通过new Observer创建一个，下面看看Observer主要做了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// observer/index.js// 每一个响应式对象都会有一个obexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value // 为什么在Observer里面声明dep？ // object里面新增或者删除属性 // array中有变更方法 this.dep = new Dep() this.vmCount = 0 // 设置一个__ob__属性引用当前Observer实例 def(value, '__ob__', this) // 判断类型 if (Array.isArray(value)) &#123; // 替换数组对象原型 if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; // 如果数组里面元素是对象还需要做响应化处理 this.observeArray(value) &#125; else &#123; // 对象直接处理 this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 在Observer构造函数中， 设置_ob_属性， 判断类型是数组还是对象，对象就直接处理，如果是数组就替换数组原型，能改变数组值的只有7个数组方法 push,pop,shift,unshift,splice,sort,reverse 然后遍历对象对每个key值执行 defineReactive 方法 其次，还额外创建了一个Dep，这是用来管理$set方法增加的属性，通知页面更新，或者数组删除和新增了元素 先看看数组覆盖的原型是如何做的 123456789101112131415161718192021222324252627282930313233//src/core/observer/array.js// 获取数组原型const arrayProto = Array.prototype// 备份export const arrayMethods = Object.create(arrayProto)const methodsToPatch = ['push','pop','shift','unshift','splice','sort','reverse']// 覆盖7个方法methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; // 执行原定任务 const result = original.apply(this, args) // 通知 const ob = this.__ob__ // 如果操作是插入操作，还需要额外响应化处理 let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 下面看看defineReacive里做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//observer/index.jsexport function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; // 和key一一对应 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; // 属性拦截，只要是对象类型均会返回childOb let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; // 获取key对应的值 const value = getter ? getter.call(obj) : val // 如果存在依赖 if (Dep.target) &#123; // 收集依赖 dep.depend() // 如果存在子ob，子ob也收集这个依赖 if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; // 如果新值是对象，也要做响应化 childOb = !shallow &amp;&amp; observe(newVal) // 通知更新 dep.notify() &#125; &#125;)&#125; 创建一个消息订阅器 Dep,内部维护了一个数组，用来收集订阅者,下面分析 在defineReactive中，通过Object.defineProperty对数据进行劫持，将属性全部转为getter/setter 在获取值的时候会触发get函数，设置新值的时候回触发set函数，函数中执行相应的操作 get函数中通过dep.depend()收集依赖 set函数中通过触发dep.notify通知更新,调用订阅器的update方法 3.Dep上面提到了一个新的东西 Dep,消息订阅器，内部有一个subs来管理依赖,看看代码是怎样实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243// onserver/dep.jsexport default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; //这里可以看出subs是用来存放Watcher的 constructor () &#123; this.id = uid++ this.subs = [] &#125; //收集Watcher addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) //Dep.target就是Watcher &#125; &#125; //通知更新，调用Watcher的update方法 notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order //如果未运行异步，则不会在调度程序中对子进行排序 //我们现在需要对其进行排序，以确保其正确触发 //订单 subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 这里面主要是通过收集Watcher管理起来，上文说到，数据变化的时候调用set函数就会触发notify，来通知Watcher的update方法，下面看看Watcher是如何实现的 4.WatcherWatcher(observer/watcher)的代码比较多，就挑一些主要代码讲解一下 在Watcher中的get函数 1234get () &#123; pushTarget(this) //...&#125; 而pushTarget函数是在observer/dep.js文件中 1234export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125; 这里把Watcher赋值给了Dep.target,所以可以通过Dep.target直接拿到在defineReactive的get函数中，直接使用get判断还有上面dep文件下的，通过下列过程，让dep收集Watcher 1234567891011121314151617181920212223242526//defineReactiveif (Dep.target) &#123; // 收集依赖 dep.depend()&#125;//src/core/observer/dep.jsdepend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) //Dep.target就是Watcher &#125; &#125;//src/core/observer/watcher.jsaddDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125;//src/core/observer/dep.jsaddSub (sub: Watcher) &#123; this.subs.push(sub)&#125; 促使页面更新，更新函数update 123456789101112update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) &#125; &#125; queueWatcher,更新队列，使用了异步更新方法，之后会有专门的文章讲解 看完Watcher的实现过程，就查找一下Watcher是在哪里调用的呢，上一篇文章说到了，在mountComponent函数中 12345678//src/core/instance/lifecycle.jsnew Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) 在页面渲染的时候，就会创建一个Watcher，所以一个组件只有一个Watcher，同一组件的每个key值收集的Watcher都会是同一个，所有有key值变化，都会触发整个组件的Watcher更新，但是虚拟dom和diff算法(之后会讲)会帮我们精确计算，要更新的部分。 5.Compiler现在整个数据响应式的流程还没有连通，初始化的时候，总得有事件会触发收集依赖吧，更新的时候也要触发重新渲染页面。这些都发生在compiler，指令解析，渲染页面的时候，页面上有的值都会去触发get函数，如果data里的数据不管嵌套有多深，但是在页面上没有使用到，都是不会去收集的。compiler的主要作用是对每个元素节点进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。compiler里面代码比较复杂，之后再虚拟dom的时候一起讲解。 6.总结 Observer： 数据监听器，能够监听属性的变化，实现数据响应式，首先要对数据进行劫持(getter/setter)，一个对象对应一个observer Watcher: 一个组件对应一个Watcher，每个key值会有一个订阅器(Dep)，如果key值在该组件中使用了，Dep就会收集当前Watcher，Watcher里面管理着更新方法(update),当数据发生变化，就会触发update方法。Watcher是连接observer和compiler的桥梁。 Compiler: 对每个元素节点进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。解析数据的时候就会触发get函数 ————-如果以上内容有不对的地方，还请大家指正———— 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》《Vue源码解析（四）：Vue批量异步更新策略》《Vue源码解析（五）：虚拟dom和diff算法》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://blog.eyes487.top/tags/MVVM/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（二）：new Vue() 初始化流程","slug":"vue-sourcec-analyse-02","date":"2020-01-27T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/01/27/vue-sourcec-analyse-02.html","link":"","permalink":"http://blog.eyes487.top/2020/01/27/vue-sourcec-analyse-02.html","excerpt":"","text":"上一篇文章已经说到如何来解读框架源码，这篇文章就通过走一遍new Vue()创建一个实例所要经过的过程来解读其中的代码所发挥的作用。下面不重要的一些代码都会通过//...省略掉 Vue版本: 2.6.11 1.new Vue()123456const app = new Vue(&#123; el: '#demo', data:&#123; msg:'hello world' &#125; &#125;) 通过断点，我们会进入instance/index.js中 123456function Vue (options) &#123; //... // 初始化 this._init(options)&#125;initMixin(Vue) // 通过该方法给Vue添加_init方法 很明显，在Vue构造函数中，只执行了this._init初始化，进入_init函数，就进入到initMixin中，可见，_init是通过下面的initMixin方法添加在函数原型上的。 2.initMixin1234567891011121314151617181920212223242526272829303132333435363738394041424344export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag // a flag to avoid this being observed vm._isVue = true // 1.合并选项,默认选项和用户传进来的选项，比如一些全局组件会被合并 // merge options if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ //2. 定义了vm._renderProxy ，后期为render做准备的，作用是在render中将this指向vm._renderProxy if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self // 3. vm._self = vm initLifecycle(vm) // $parent, $root, $children, $refs initEvents(vm) // 对父组件传入事件添加监听 initRender(vm) // 声明$slots,$createElement() callHook(vm, 'beforeCreate') // 调用beforeCreate钩子 initInjections(vm) // 注入数据 initState(vm) // 重要：数据初始化，响应式 initProvide(vm) // 提供数据 callHook(vm, 'created') if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 这个方法主要是为Vue原型上添加_init方法，而在_init方法中做的几件事情使我们要关注的。 mergeOptions 合并选项 定义了vm._renderProxy 其他方法(重要)，下面具体介绍 2.1 initLifecycle1234567891011121314151617181920212223242526export function initLifecycle (vm: Component) &#123; const options = vm.$options // locate first non-abstract parent //建立所有组件的父子关系 let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 在这里是一些跟声明周期相关变量的初始化，比如: 父亲($parent),祖先($root),孩子($children),引用($refs) 2.2 initEvents12345678910export function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events //将父组件模板中注册的事件放到当前组件实例的listeners里面 const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 处理父组件传入的事件和回调，事件是谁派发谁监听 2.3 initRender123456789101112131415161718192021222324252627282930313233export function initRender (vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // 给编译器生成渲染函数使用的，内部使用 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // render(h) 此处的$createElement就是h // 用户render使用的 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated //公开$ attrs和$ listeners以便于创建HOC。 //它们必须是反应性的，以便始终更新使用它们的HOC const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true) &#125; else &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true) &#125;&#125; 这个函数中，做的主要的两件事情就是声明 $slot ,$createElement 2.4 callHook123456789101112131415export function callHook (vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] const info = `$&#123;hook&#125; hook` if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info) &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit('hook:' + hook) &#125; popTarget()&#125; 调用钩子函数，这里调用了beforeCreate，之前声明的变量，此时都可以调用了，下面会用此方法调用created 2.5 initInjections/initProvide先理解Vue2.0中的Provide/inject 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 1234567891011121314151617181920212223242526//将$options里的provide赋值到当前实例上export function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === 'function' ? provide.call(vm) : provide &#125;&#125;export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) //这个方法主要就是对inject属性中的各个key进行遍历，然后沿着父组件链一直向上查找provide中和inject对应的属性，直到查找到根组件或者找到为止，然后返回结果 if (result) &#123; //对result的一些处理，比如在非生产环境会将result里的值定义成相应式的。 toggleObserving(false) Object.keys(result).forEach(key =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; //... &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125; 注入数据和提供数据，注入数据之后要判重，或者做一些其他的操作，提供给其他组件，所以注入数据在提供数据之前 2.6 initState1234567891011121314151617export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 属性初始化 if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) // 数据响应式 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 数据响应式，这是很重要的一部分，先大致看看做了什么操作，详细了解Vue源码解析（三）：数据响应式 2.7 $mount下面就执行挂载方法了 123if (vm.$options.el) &#123; vm.$mount(vm.$options.el)&#125; 之前提到过，$mount是在entry-runtime-with-compiler.js中做了一些额外的判断，但主要的实现方法是在runtime/index.js中 123456789// 实现$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined // 初始化，将首次渲染结果替换el return mountComponent(this, el, hydrating)&#125; 然后调用mountComponent()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') &#123; //... &#125; &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; //... &#125; &#125; else &#123; // 用户$mount()时，定义updateComponent updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) //会通过new Watcher中的get方法调用 &#125; &#125; // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined //我们将其设置为观察者构造函数中的vm._watcher //因为观察者的初始补丁可能会调用$ forceUpdate（例如，在child内部 //组件的挂接钩），它依赖于已定义的vm._watcher new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook //手动安装的实例，在自身上调用安装 //mount在其插入的钩子中被渲染创建的子组件调用 if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; vm._update 会调用 vm.render()方法,先执行render方法返回vnode，在通过update转换为真实dom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options //从vm.options中拿到的变量来自于 instance/index.js中给实例添加的属性,通过调用下面这些方法 //stateMixin(Vue) // $set,$delete,$watch // eventsMixin(Vue) // $emit,$on,$off,$once // lifecycleMixin(Vue) // _update(),$forceUpdate(),$destroy() // renderMixin(Vue) // _render(), $nextTick if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. //设置父vnode。这使得渲染功能可以访问 //到占位符节点上的数据。 vm.$vnode = _parentVnode // render self let vnode try &#123; currentRenderingInstance = vm // vm.$createElement就是h vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; //... &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; //... &#125; // set parent vnode.parent = _parentVnode return vnode &#125;&#125; 12345678910111213141516171819202122232425262728Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) //这句执行为页面就变为真实dom了，页面数据就发生变化了 &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) //diff算法就是在这里发生的，之后会有文章仔细说明 &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; &#125; 3.总结梳理一下创建实例的整个流程 new Vue(): 调用init this._init(): 初始化各种属性 $mount: 调用mountComponent mountComponent: 声明updateComponent、创建Watcher _render(): 获取虚拟dom _update(): 把虚拟dom转换为真实dom 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》《Vue源码解析（四）：Vue批量异步更新策略》《Vue源码解析（五）：虚拟dom和diff算法》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"Vue源码解析（一）：如何解读源码","slug":"vue-sourcec-analyse-01","date":"2020-01-26T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2020/01/26/vue-sourcec-analyse-01.html","link":"","permalink":"http://blog.eyes487.top/2020/01/26/vue-sourcec-analyse-01.html","excerpt":"","text":"以前听人说解读一个框架的源码，最好的方法就是自己写一个小实例，通过浏览器断点（f10，应该大家都知道的）看运行这个实例执行了哪些步骤，想知道某个方法是如何实现的，就执行某个方法，通过断点查看它到底做了些什么。这个方法是很有用的，今天就通过此方法向大家介绍解读源码的步骤。 Vue版本: 2.6.11 1.准备工作1.1 克隆源码123地址： https://github.com/vuejs/vue通过命令： git clone https://github.com/vuejs/vue.git当前版本： 2.6.10 1.2 安装依赖12安装依赖： cd vue &amp;&amp; npm install 打包工具rollup： npm install rollup -g (如果以前没有安装) 1.3 修改dev脚本在package.json中 在scripts中找到dev，添加 –sourcemap，如下 123\"scripts\": &#123; \"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\", \"dev:cjs\": \"rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev\", 文件打包之后都是一个压缩文件，通过sourcemap可以定位源文件 1.4 执行1npm run dev 打包之后，会在dist文件夹下新增一个vue.js.map文件，vue.js也会被修改这样准备工作就算完成了 2.目录结构下面是一些核心文件，以及他们的用途 123456dist- - -发布目录，所有输出文件都在里面 （打包出的文件，关键字含义） runtime- - -仅包含运行时，不包含编译器 common- - -cjs规范，用于webpack1 esm- - -ES模块，用于webpack2+ umd(什么都不带的)- - -兼容cjs和amd，一般用于浏览器 3.查找入口文件3.1 在package.json中，dev命令中1\"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\", 代码里可以发现两个关键点 scripts/config.js和web-full-dev,所以去到config.js可以发现 123456789// Runtime+compiler development build (Browser) 'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), //&lt;=====这个文件 dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, 3.2 web/entry-runtime-with-compiler.js这个文件位于 src/platforms/web/下面 如果遇到/* istanbul ignore if */,这个代码不重要，甚至可以直接删掉，只用于调试阶段，下面我贴的源码就直接删掉以节约空间了,只会贴出主要代码,重要部分都会写上注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import Vue from './runtime/index'...// 保存原来的$mountconst mount = Vue.prototype.$mount// 覆盖默认$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) // 解析option const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template // 模板解析 if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template) &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; // 如果存在模板，执行编译 if (template) &#123; // 编译得到渲染函数 const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns &#125; &#125; // 执行挂载 return mount.call(this, el, hydrating)&#125;function getOuterHTML (el: Element): string &#123; if (el.outerHTML) &#123; return el.outerHTML &#125; else &#123; const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML &#125;&#125;Vue.compile = compileToFunctions 从代码可以看出，new Vue的时候，优先级是render，template，el，最终都是得到render函数 这个文件的主要作用：覆盖$mount,执行模板解析和编译工作 这个文件发现Vue引入自runtime/index 3.3 runtime/index.js123456789101112131415161718import Vue from 'core/index'import &#123; extend, noop &#125; from 'shared/util'import &#123; mountComponent &#125; from 'core/instance/lifecycle'// install platform patch function// 指定补丁方法：传入虚拟dom转换为真实domVue.prototype.__patch__ = inBrowser ? patch : noop// public mount method// 实现$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined // 初始化，将首次渲染结果替换el return mountComponent(this, el, hydrating)&#125; 这个文件主要定义$mount方法和其他额外配置 这个文件发现Vue引入自core/index 3.4 core/index.js12345import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'// 定义全局apiinitGlobalAPI(Vue) 这个文件主要定义全局api，在Vue山挂在一些其他方法 这个文件发现Vue引入自instance/index 3.5 instance/index.js123456789101112131415161718192021222324import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'// 构造函数function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; // 初始化 this._init(options)&#125;initMixin(Vue) // 通过该方法给Vue添加_init方法stateMixin(Vue) // $set,$delete,$watcheventsMixin(Vue) // $emit,$on,$off,$oncelifecycleMixin(Vue) // _update(),$forceUpdate(),$destroy()renderMixin(Vue) // _render(), $nextTickexport default Vue 终于在这个文件中找到了Vue构造函数，里面只执行了init方法，init方法是通过initMixin()给Vue添加_init方法 同时，也添加了很多实例方法 在init.js文件中initMixin()方法 12345678910// 主要代码 vm._self = vm initLifecycle(vm) // $parent, $root, $children, $refs initEvents(vm) // 对父组件传入事件添加监听 initRender(vm) // 声明$slots,$createElement() callHook(vm, 'beforeCreate') // 调用beforeCreate钩子 initInjections(vm) // 注入数据 initState(vm) // 重要：数据初始化，响应式 initProvide(vm) // 提供数据 callHook(vm, 'created') 这次主要是寻找入口文件，所以没有对里面的方法去进行深究，之后会有专门的文章对他们进行解读 4. 实例在examples中，建一个test.html 12345678910111213141516&lt;head&gt; &lt;script src=\"../../dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;div id=\"demo\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script&gt; // 创建实例 const app = new Vue(&#123; el: '#demo', // template: '&lt;div&gt;template&lt;/div&gt;', // render(h)&#123;return h('div','render')&#125;, data:&#123;msg:'hello world!!!!!'&#125; &#125;)&lt;/script&gt; 就可以通过断点在浏览器中看到执行的过程了，如果想看某个方法具体执行了什么，就进入该方法查看，从开始到浏览器渲染完成，就是整个渲染流程所执行的过程。 Vue源码解读方法，差不多就是这样了，之后会有具体文章分析Vue的重要实现过程。学习源码，知道大概思路，设计思想就行了，不用太深究其细节，框架也是一个产品，里面会包含大量业务代码。框架中，基本都是使用英文注释，对英文不太好的朋友会不太友好，vscode中推荐使用comment Translate这个插件，可以把注释翻译成中文。 目录《Vue源码解析（一）：如何解读源码》《Vue源码解析（二）：new Vue() 初始化流程》《Vue源码解析（三）：数据响应式》《Vue源码解析（四）：Vue批量异步更新策略》《Vue源码解析（五）：虚拟dom和diff算法》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"http://blog.eyes487.top/tags/源码/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"记一次性能优化，从六七秒优化到1.35s","slug":"one-time-optimization","date":"2019-12-07T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2019/12/07/one-time-optimization.html","link":"","permalink":"http://blog.eyes487.top/2019/12/07/one-time-optimization.html","excerpt":"","text":"👇👇👇👇👇👇👇👇👇👇👇👇👇👇 更新—-2020.06.07 👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 最近学习了http2，所以想将自己的网站也升级http2试一下，升级之后页面加载速度确实提高了，速度达到了711ms,查看地址 准备工作 域名，之前搞活动买的，挺便宜 服务器备案，我使用的阿里云服务器，上传自己信息，几天就通过了 ssl证书，我在阿里云申请的免费的 升级HTTPShttp2默认只支持https，所以必须先升级https。我使用的nginx服务器，之前就已经安装过了。要升级https，首先nginx安装需要的模块--with-http_ssl_module，如果是通过yum install nginx安装的nginx，它是已经包含了所有模块的，就不需要安装了，只有通过压缩包安装的才需要单独安装模块，然后把ssl证书放到服务器上，配置nginx.conf,然后重启就可以看到已经支持https请求了。网上有很多教程，这里就不细说我的步骤了。 升级HTTP2支持https之后，步骤和上面差不多，nginx先安装模块--with-http_v2_module,之后再配置nginx.conf。网上教程很多，我就不说具体步骤了，说一下我遇到的问题。 我配置了HTTP2之后并没有起作用，然后也是在网上搜了一大堆问题，都是说了两个问题，http2必须满足两个条件： nginx版本要高于1.9.5 openssl版本要高于1.0.2e 但是我发现，这两个要求我都是满足的，但是就是不起效果，折腾了好久。 最后，通过重新启动nginx解决了，这里说的重启并不是指./nginx -s reload,而是你必须先关掉./nginx -s quit,然后在开启./nginx。 难怪很多解决不了的问题，都通过重启解决，O(∩_∩)O哈哈~ 👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆 更新—-2020.06.07 👆👆👆👆👆👆👆👆👆👆👆👆👆👆 这是在还没毕业做的一个项目，一直放在之前的服务器上，不久之前服务器到期了。趁着双十一的机会，优惠很大就又买了一个，把项目迁移到新的服务器上。首页加载的速度有六七秒左右，以前也优化过一些，但以前技术有限，就没怎么管它了。这次趁着换新服务器，就想着来优化一下网站。网速、电脑响应速度等 都会对页面加载速度有影响，基本可以稳定在 1秒多(未使用CDN)，先上网站地址 花间道,下面从我所用到的优化方法介绍。 1. 减少http请求数众所周知，减少 http 请求数是缩短页面加载时间最有效的方法 资源压缩和合并，尽可能的将外部的脚本、样式进行合并，多个合为一个。 使用 CSS Sprites，通过背景定位获取具体图像 合理的设置http缓存 1.1 合并压缩合并压缩的构建工具有，gulp，webpack，grunt等，我当时使用的是gulp，gulp不能处理ES6代码，所以还是得用webpack，是否要合并代码还是要具体看自己的需求。这个就自己去查看webpack了。 下面是使用gulp处理less转化为css，并且会压缩代码 123456gulp.task('less',function () &#123; gulp.src('public/less/*.less') .pipe(gulp_less()) .pipe(gulp_minify_css()) .pipe(gulp.dest('public/stylesheets'))&#125;); 1.2 CSS Sprites推荐自动生成雪碧图的工具: https://www.toptal.com/developers/css/sprite-generatorwebpack 中有一款生成雪碧图的插件，webpack-spritesmith,会自动帮你生成调用雪碧图的css样式 1.3 http缓存http缓存分为 强制缓存 和 协商缓存 强制缓存在响应头中会有（Expires/Cache-Control）,Expires是1.0的东西，在http 1.1都是用Cache-Control代替了 Cache-Controlprivate 客户端可以缓存public 客户端和代理服务器都可以缓存max-age=60 缓存内容将在60秒后失效no-cache 需要使用对比缓存验证数据,强制向源服务器再次验证. 禁用强制缓存no-store 所有内容都不会缓存，强制缓存和对比缓存都不会触发。 12345678910111213141516171819202122232425262728let http = require('http');let url = require('url');let path = require('path');let fs = require('fs');let mime = require('mime');http.createServer(function (req, res) &#123; let &#123; pathname &#125; = url.parse(req.url, true); let filepath = path.join(__dirname, pathname); console.log(filepath); fs.stat(filepath, (err, stat) =&gt; &#123; if (err) &#123; return sendError(req, res); &#125; else &#123; send(req, res, filepath); &#125; &#125;);&#125;).listen(8080);function sendError(req, res) &#123; res.end('Not Found');&#125;function send(req, res, filepath) &#123; res.setHeader('Content-Type', mime.getType(filepath)); //expires指定了此缓存的过期时间，此响应头是1.0定义的，在1.1里面已经不再使用了 res.setHeader('Expires', new Date(Date.now() + 30 * 1000).toUTCString()); res.setHeader('Cache-Control', 'max-age=30'); //设置缓存时间为30s fs.createReadStream(filepath).pipe(res);&#125; 协商缓存使用 Etag/If-None-Match , Last-Modified/If-Modify-Since 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 使用 Last-Modified/If-Modify-Since方法 1234567891011121314151617181920212223242526272829303132http.createServer(function (req, res) &#123; let &#123;pathname&#125; = url.parse(req.url); let filepath = path.join(__dirname,pathname); console.log(filepath); fs.stat(filepath,function (err, stat) &#123; if (err) &#123; return sendError(req,res) &#125; else &#123; // 再次请求的时候会问服务器自从上次修改之后有没有改过 let ifModifiedSince = req.headers['if-modified-since']; let LastModified = stat.ctime.toGMTString(); if (ifModifiedSince == LastModified) &#123; res.writeHead('304'); res.end('') &#125; else &#123; return send(req,res,filepath,stat) &#125; &#125; &#125;)&#125;).listen(8080)function send(req,res,filepath,stat) &#123; res.setHeader('Content-Type', mime.getType(filepath)); // 发给客户端之后，客户端会把此时间保存下来，下次再获取此资源的时候会把这个时间再发给服务器 res.setHeader('Last-Modified', stat.ctime.toGMTString()); fs.createReadStream(filepath).pipe(res)&#125;function sendError(req,res) &#123; res.end('Not Found')&#125; 使用 Etag/If-None-Match方法, Etag 的优先级高于 Last-Modified 12 2.图片优化我的网站访问起来太慢，最主要的原因还是由于使用了大量图片，除了压缩图片，上面说了可以使用雪碧图来减少图片请求，还可以使用字体图标代替一些小图片，其次使用webp格式，可以减少图片的大小。 使用图片的时候，尽量指定图片大小，不要缩放图片,如果网页中需要什么尺寸的图片，就设计什么尺寸的图片。因为浏览器下载到原始图片之后，如果尺寸与目标尺寸不合，浏览器就会去处理图片(拉伸或者缩小)，造成浏览器负担。 2.1 使用字体图标我使用的是fontawesome,但是文件体积有点大，我请求 fontawesome-webfont.woff2?v=4.7.0这个文件的时候，要花1秒多，里面有很多的图标其实我并没有用到。推荐一个网站，http://fontello.com/,可以到里面选择自己需要的图标，然后下载下来，替换掉fontawesome-webfont.woff 这个文件。当然也可以用 IconFont，只是我之前是fontawesome，我懒得换了。 2.2 使用webp格式推荐一个网址，可以转换图片格式为webp，https://www.upyun.com/webp webp使用方法 12345//html中&lt;picture&gt; &lt;source type=\"image/webp\" srcset=\"123.webp\"&gt; &gt; &lt;img src=\"123.jpg\" alt=\"\"&gt;&lt;/picture&gt; 12345678910111213141516171819//首先判断浏览器是否支持webp格式，给文档加上data-webp属性function isSupportWebp() &#123; var flag = '0'; var canvasEL = document.createElement('canvas'); var docEl = document.documentElement || document.getElementsByTagName('html')[0]; if (canvasEL.getContext &amp;&amp; canvasEL.getContext('2d')) &#123; flag = canvasEL.toDataURL('image/webp').indexOf('image/webp') &gt; -1 ? '1': '0' &#125;; docEl.setAttribute('data-webp', flag); return flag&#125;;// 然后在背景图片中引用,css文件中[data-webp=\"0\"] div&#123; background: ur(\"./123.jpg\")&#125;[data-webp=\"1\"] div&#123; background: ur(\"./123.webp\")&#125; 推荐谷歌的性能检测工具—PageSpeed,在谷歌网上商店可以找到，里面会帮你提供有哪些需要改进的地方，在优化图片中会帮你把图片压缩一下，可以直接下载下来使用 3. Gzip传输压缩在服务器开启Gzip压缩，可以将文件在传输的时候体积压缩70% 左右，所有浏览器都支持gzip解压，都是自动的。 不要对图片进行压缩，首先http压缩是需要成本的，其次，采用HTTP压缩已经被过压缩的东西并不能使它更小。图片压缩不仅浪费了CPU，还有可能增大图片的体积。 我使用的是 nginx,通过在 nginx.config 配置下面代码 123456gzip on; //打开gzipgzip_min_length 1k; //当返回内容大于此值时才会使用gzip进行压缩,以K为单位,当值为0时，所有页面都进行压缩。#gzip_http_version 1.0; //用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在http/1.0的协议下不开启gzip压缩。gzip_comp_level 2; //设置gzip压缩级别，级别越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; //设置需要压缩的MIME类型,如果不在设置类型范围内的请求不进行压缩gzip_vary off; //是否启用应答头\"Vary: Accept-Encoding\" 设置成功之后，请求的响应头中会带有gzip字段 4. CDN加速CDN加速意思就是在用户和我们的服务器之间加一个缓存机制，通过这个缓存机制动态获取IP地址根据地理位置，让用户到最近的服务器访问。我们是不可能自己搭建CDN的，所以只有从阿里云，腾讯云之类的购买。因为我暂时不需要，所以就没有使用。(￣ˇ￣) 5. 代码优化 css应该放在页面首部，在页面生成Dom tree的时候，就可以同时渲染页面，不会发生闪屏，白屏和布局混乱。 js是会阻塞页面加载的，所以js可以放在页面尾部，或者使用defer等延迟加载。 使用渐进式加载图片，先用分辨率的图片，等空闲时间在切换高清图片。 减少操作dom的次数，把多次操作变为一次操作，比如脱离文档流，隐藏元素等 重排一定会重绘，更应该减少重排的发生 下面是我用PageSpeed测试的结果，查询数据的接口，我认为没有做缓存的必要，所以就没有做缓存 参考链接： https://juejin.im/post/5b6fa8c8…","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"js 性能优化","slug":"js-性能优化","permalink":"http://blog.eyes487.top/tags/js-性能优化/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"自建图床：上传图片 懒加载 瀑布流显示","slug":"a-picture-bed","date":"2019-11-16T00:00:00.000Z","updated":"2020-07-23T12:22:45.189Z","comments":true,"path":"2019/11/16/a-picture-bed.html","link":"","permalink":"http://blog.eyes487.top/2019/11/16/a-picture-bed.html","excerpt":"","text":"一般大家写博客的时候，都会使用外链图片，我也使用过几个免费的图床，但是效果都不太理想。也只是偶尔需要用图，使用付费的也不合算。自己的服务器上也没多少东西，所以就在自己服务器上搭了一个。比较简单，上传图片，页面显示，部署到服务器上就行了。查看地址 查看完整代码请戳这里,下面会对关键性代码做一些讲解。 1.上传图片1.1 html代码12&lt;input type=\"file\" multiple id=\"file\"&gt;&lt;input type=\"button\" value=\"上传\" id=\"upload\"&gt; 页面是这个样子，当然可以自己加一些css样式 1.2 js代码123456789101112131415161718192021222324var fileinput = document.getElementById('file')// 选择文件fileinput.onchange = () =&gt; &#123; var files = fileinput.files; let imgDOMArray = new Array(files.length) let reader = [] let thumbPic = [] for (let i = 0; i &lt; files.length; i++) &#123; reader[i] = new FileReader() thumbPic[i] = document.createElement('div') imgDOMArray[i] = document.createElement('img') imgDOMArray[i].file = files[i] thumbPic[i].className = 'thumbPic' thumbPic[i].appendChild(imgDOMArray[i]) previewDOM.appendChild(thumbPic[i]) reader[i].readAsDataURL(files[i]) reader[i].onload = (img =&gt; &#123; return e =&gt; &#123; img.src = e.target.result &#125; &#125;)(imgDOMArray[i]) &#125;&#125; 选择文件，选择之后，可以把图片显示在下面，方便查看 下面是使用ajax向后台发送上传图片请求，上传图片需要使用FormData格式，向后台发送数据，ajax提供了xhr.upload.onprogress可以监听文件上传的进度，这个必须在send之前设置 12345678910111213141516171819202122232425262728293031323334var button = document.querySelector('#upload')button.onclick = uploadFile;function uploadFile() &#123; var xhr = new XMLHttpRequest(); var formdata = new FormData() var files = fileinput.files if (!files[0]) &#123; alert('请先选择图片，再上传！') return &#125; for (let i = 0; i &lt; files.length; i++) &#123; formdata.append('imgfile', files[i], files[i].name) &#125; xhr.open('POST', BASE_URL+'/uploadimg') //可以查看上传的进度 xhr.upload.onprogress = e =&gt; &#123; var current = e.loaded; //当前上传多少size var total = e.total; //总共size if (e.lengthComputable) &#123; //... if (percentComplete &gt;= 100) &#123; //... &#125; &#125; &#125; xhr.send(formdata) xhr.onload = () =&gt; &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status === 200) &#123; //上传成功 &#125; &#125;&#125; 1.3 服务端代码服务端代码，使用node + express，可以快速的搭建服务端代码 1npm install express -S 然后新建server.js, 1234567var express = require(\"express\");var app = express();var server = app.listen(9999, function() &#123; console.log('server is running at port 9999...');&#125;); 这样就搭好服务器了，可以通过localhost:9999,直接访问服务器了 Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。安装 multer 1npm install multer -S 在server.js中加入 12345678910111213//server.jsvar multer = require(\"multer\");var storage = multer.diskStorage(&#123; destination: function(req, file, cb) &#123; cb(null, './public/uploads'); //把上传的文件保存在 这个地址下面 &#125;, filename: function(req, file, cb) &#123; cb(null, `$&#123;Date.now()&#125;-$&#123;file.originalname&#125;`) //对上传的文件，改名，可能上传的会有重名文件 &#125;&#125;)var uploadFile = multer(&#123; storage: storage &#125;); multer 提供了 storage 这个参数来对资源保存的路径、文件名进行个性化设置。 下面编写接口 1234//server.jsapp.post('/uploadimg', uploadFile.array('imgfile', 10), function(req, resp, next)&#123; resp.send(&#123; status: 200, message: '上传成功'&#125;)&#125;) 上传文件接口uploadimgupload.array(‘imgfile’, 10), 表示接收一个以imgfile命名的数组，长度最大为10。这样就上传到服务器了 但是，我们不只把图片存到服务器就行了，还需要保存图片信息到数据库 这里数据库使用 mysql 1npm install mysql -S 连接数据库，封装一个连接数据库的文件 123456789101112131415161718192021222324// db.jsvar mysql = require('mysql');var dbConn=&#123; configure:&#123; host:\"localhost\",//主机地址 port:\"3306\",//主机端口 user:\"root\",//用户名 password:\"123456\",//主机密码 database:\"image_store\"//数据库名 &#125;, sqlConnect:function(sql,values,callback)&#123; var pool=mysql.createPool(this.configure); pool.getConnection(function(error,connection)&#123; if(error)&#123; console.log('数据库---',error) &#125; connection.query(sql,values,callback); connection.release(); &#125;); &#125;&#125;module.exports=&#123; dbConn:dbConn&#125; 上面上传文件的时候，就可以改成这样 12345678910111213141516171819202122232425const db = require('./db');app.post('/uploadimg', uploadFile.array('imgfile', 10), upload)function upload(req, resp, next) &#123; var files = req.files var names = []; for(let i = 0;i &lt; files.length; i++)&#123; names.push(\"('\"+files[i].filename+\"')\"); &#125; var sql = \"insert into img_list (imgSrc)values \" + names.join(','); db.dbConn.sqlConnect(sql,[],function(err,data)&#123; if(err)&#123; resp.status(500).send(&#123; status: 500, message: err &#125;) &#125;else&#123; resp.send(&#123; status: 200, message: '上传成功' &#125;); &#125; &#125;)&#125; upload中插入上传的文件名到img_list表中，上传多张图片就插入多条数据。上传图片就算完成了。 2.渲染页面使用瀑布流显示页面上的图片，做瀑布流的方法有多种，这里我使用了绝对定位的方法来实现，然后下拉刷新，根据滚动条的高度来实现懒加载。 2.1 瀑布流查询图片列表，服务端代码 12345678910111213141516171819202122232425262728293031323334353637const fs = require('fs');const image = require(\"imageinfo\");//查询列表const getImageList = function(req,resp)&#123; const pageNum = req.query.pageNum || 1; const pageSize = req.query.pageSize || 10; const sql = \"select * from img_list order by id desc limit ?, ?\"; db.dbConn.sqlConnect(sql,[(pageNum-1)*pageSize,pageSize*1],function(err,data)&#123; if(err)&#123; resp.status(400).send(&#123; status: 400, message: err &#125;) &#125;else&#123; let newData = getImageFiles('public/uploads/',data) resp.send(&#123; status: 200, data: newData, message: '查询成功' &#125;); &#125; &#125;)&#125;//获取指定图片的尺寸function getImageFiles(path,data) &#123; if(!data.length)&#123; return [] &#125; var imageList = []; data.forEach((item) =&gt; &#123; var ms = image(fs.readFileSync(path + item.imgSrc)); ms.mimeType &amp;&amp; (imageList.push(&#123;...item,width: ms.width, height: ms.height&#125;)) &#125;); return imageList;&#125; 从数据库按照倒叙，插叙最新的图片名称，查询之后需要对数据信息做一些处理。 用到了fs 和 image两个插件 1npm install fs image -S fs是读取存在服务器上的图片文件，image可以获取图片的具体信息,我们会返回图片的宽和高。之后做瀑布流渲染，需要拿到图片的宽和高。 在前端请求接口，请求数据列表 12345678910111213function getImageList() &#123; canLoad = false; //请求数据时，改为不可加载 var xhr = new XMLHttpRequest(); xhr.open('GET', BASE_URL+`/getImageList?pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageSize&#125;`); xhr.send(); xhr.onload = () =&gt; &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status === 200) &#123; let res = JSON.parse(xhr.responseText); let data = res.data; renderImage(data); &#125; &#125;&#125; 请求数据之后，就依据数据生成相应的dom,使用渲染函数 renderImage 123456789101112131415161718192021222324252627/** * 渲染图片 * @param &#123;*&#125; list 图片数据 */function renderImage(list) &#123; let Node = []; //定义一个数组，把创建的节点存储起来，方便后面修改这些节点的位置信息 let Fragment = document.createDocumentFragment(); for (let i = 0, len = list.length; i &lt; len; i++) &#123; let Div = document.createElement('div'); Div.setAttribute('class','image-item'); Div.innerHTML = ` &lt;input type=\"checkbox\" class=\"delete-checkbox\" onClick=\"selectDeleteImg(this,'$&#123;list[i].id&#125;','$&#123;list[i].imgSrc&#125;')\"&gt; &lt;img class=\"img\" src=\"./uploads/$&#123;list[i].imgSrc&#125;\"/&gt; &lt;p class=\"desc\"&gt;$&#123;list[i].imgSrc&#125;&lt;/p&gt; `; Node.push(Div) Fragment.appendChild(Div); &#125; //设置新增加点的位置 change(Node,list); imageList.appendChild(Fragment) //渲染完之后 if(!(list.length &lt; pageSize))&#123; pageNum++; canLoad = true; &#125;&#125; 这里定义了一个Node数组来存储新创建的节点，是为了在change函数中遍历这个数组，来为节点设置定位信息，同时，也把节点放进了Fragment中，这样之后就可以一次性追加进页面中，提高性能。在渲染完页面之后，把pageNum和canLoad标记重新复制。canLoad是一个变量，用来判断现在是否正在请求列表，防止多次触发。 change方法 123456789101112131415161718192021222324252627282930313233343536373839/** * 改变指定图片尺寸 * @param &#123;*&#125; Items dom元素 * @param &#123;*&#125; source 图片数据，窗口改变大小时不传 */var windowCW = document.documentElement.clientWidth, //窗口视口的宽度 n = Math.floor(windowCW / 410), //一行能容纳多少个div，并向下取整 center = (windowCW - n * 410) / 2, //居中 arrH = []; //定义一个数组存放每个item的高度function change(Items,source) &#123; if (n &lt;= 0) &#123; return &#125;; for (var i = 0; i &lt; Items.length; i++) &#123; var j = i % n; let height = source ? Math.ceil(380/(source[i].width/source[i].height))+70 : Items[i].offsetHeight; //根据图片设置宽度380，同比缩放高度 if (arrH.length == n) &#123; //一行排满n个后到下一行 var min = findMin(arrH); //从最“矮”的排起，可以从下图的序号中看得出来，下一行中序号是从矮到高排列的 Items[i].style.left = center + min * 410 + \"px\"; Items[i].style.top = arrH[min] + 10 + \"px\"; arrH[min] += height + 10; &#125; else &#123; arrH[j] = height; Items[i].style.left = center + 400 * j + 10 * j + \"px\"; Items[i].style.top = 0; &#125; &#125;;&#125;/** * 查询数组中最小的数据 * @param &#123;*&#125; arr */function findMin(arr) &#123; var m = 0; for (var i = 0; i &lt; arr.length; i++) &#123; m = Math.min(arr[m], arr[i]) == arr[m] ? m : i; &#125; return m;&#125; 瀑布流就是图片宽度相等，但是高度不相等，这里我设置的宽度是 380 ，图片容器会有padding:10 首先根据窗口的宽度，定义了一行能够容纳n张 图片，包括图片容器的宽度都要计算在内 center是为了居中显示，判断了除去图片的宽度，在除以2，就是left开始的位置 arrH 定义一个数组，用来存放n列图片中，每列图片的高度总和，下一张图片就会从最矮的那一列开始排列 每张图片高度，会根据后台返回的数据中带有宽高，根据定义的固定宽度(380)来等比缩放，判断高度应该是多少，但是当窗口发生改变的时候，我们不会再传入源数据，这时候直接使用Items[i].offsetHeight，应为节点之前已经渲染过了，所以直接会有offsetheight 循环所有节点，先把第一行排满，排满之后就开始通过findMin(arrH)寻找高度最低的那一列下标，放在这一列，在把这一列高度加上这个图片的高度，就这样循环完所有节点 当窗口的宽度改变的时候，需要重新计算所有节点的位置 1234567891011121314/** * 重新计算窗口宽度 */function resetSize()&#123; windowCW = document.documentElement.clientWidth; //窗口视口的宽度 n = Math.floor(windowCW / 410); //一行能容纳多少个div，并向下取整 center = (windowCW - n * 410) / 2; //居中 arrH = []; //定义一个数组存放每个item的高度&#125;window.onresize = function&#123; var Items = document.querySelectorAll('.image-item') resetSize(); change(Items);&#125; 这样，瀑布流展示就做完了。查看效果点击这里 2.2 懒加载2.2.1 分页查询懒加载就是页面开不到的地方先不加载，等页面滑到的地方在去请求数据 1234567891011121314/** * 懒加载 */window.onscroll = function ()&#123; let height = arrH.length &amp;&amp; arrH[findMin(arrH)]; if(canLoad &amp;&amp; height)&#123; let scrollTop = document.documentElement.scrollTop; let clientHeight = document.documentElement.clientHeight; if(scrollTop + clientHeight &gt; height)&#123; getImageList() &#125; &#125;&#125; 当 滚动条高度 加上 文档可视区的高度 要大于 arrH中最小的高度，也就是页面上图片最小高度总和的时候，就需要加载新的数据了。同时还需要通过 canLoad变量判断，防止多次加载，或者后面已经没有数据的时候，这个变量就会变为不可加载。 2.2.2 IntersectionObserver 可视区域加载上面通过请求接口的方式实现的懒加载,也可以通过图片按需加载实现. IntersectionObserver ,可以用来监听元素是否加入设备的可视区域之内,我们可以通过监听dom是否进入可视区域,再去加载图片。(ie现在还不支持) 在上面renderImage 函数中，渲染图片的时候，先不指定src地址，指定一个data-src属性,渲染图片dom之后，要监听initObserver();函数，下面会说到它的实现方法 12345678910function renderImage(list) &#123; // ... Div.innerHTML = ` &lt;input type=\"checkbox\" class=\"delete-checkbox\" onClick=\"selectDeleteImg(this,'$&#123;list[i].id&#125;','$&#123;list[i].imgSrc&#125;')\"&gt; &lt;img class=\"img\" data-src=\"./uploads/$&#123;list[i].imgSrc&#125;\"/&gt; &lt;p class=\"desc\"&gt;$&#123;list[i].imgSrc&#125;&lt;/p&gt; `; //... initObserver();&#125; 123456789101112131415161718const observer = new IntersectionObserver(function(changes) &#123; changes.forEach(function(element, index) &#123; // 当这个值大于0，说明满足我们的加载条件了，这个值可通过rootMargin手动设置 if (element.intersectionRatio &gt; 0) &#123; // 放弃监听，防止性能浪费，并加载图片。 observer.unobserve(element.target); element.target.src = element.target.dataset.src; &#125; &#125;);&#125;);function initObserver() &#123; const listItems = document.querySelectorAll('.img'); listItems.forEach(function(item) &#123; // 对每个list元素进行监听 observer.observe(item); &#125;);&#125; 这样就实现了 图片的可视区域加载，在控制台network中, 可以查看到，页面滚动到某个位置，某个位置的图片才去进行加载。 还有一些其他的功能，比如查看大图，删除图片等，这里就不细说了，如果感兴趣的可以去查看完整代码","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"上传文件","slug":"上传文件","permalink":"http://blog.eyes487.top/tags/上传文件/"},{"name":"js","slug":"js","permalink":"http://blog.eyes487.top/tags/js/"},{"name":"node","slug":"node","permalink":"http://blog.eyes487.top/tags/node/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"React Native 开发中所遇到的问题","slug":"problem-of-react-native","date":"2019-10-21T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2019/10/21/problem-of-react-native.html","link":"","permalink":"http://blog.eyes487.top/2019/10/21/problem-of-react-native.html","excerpt":"","text":"入坑React Native半年多了，平时也会遇到一些问题，但是解决之后，下次遇到可能就记不得，现在已经想不起之前遇到的一些问题了，所以想记录下来，方便以后可以回顾，如果有遇到类似问题的人，也可以有一个参考，这篇博客会不定期累加问题。 1.Task :app:compileDebugJavaWithJavac FAILED 一般导致这种错误的情况会有很多，大部分时候，我在发生这种错误时，在控制台启动项目的时候会报出错误的文件，或者执行gradlew compileDebugJavaWithJavac 命令也可以看到具体的错误信息,利用Android Studio查看错误的文件，可以看到具体是哪行发生了错误。 一般我遇到的错误，大部分是引用错误，在升级了AndroidX之后，可是之前引用的一些包会不兼容，需要把android引用改为androidx的。 这些错误一般都是由于引用的第三方库里发生的错误，也就是node_modules中的文件，每次npm之后，node_modules中的文件就会更新，所以每次去改就很麻烦。可以把第三方库fork到自己的git仓库中，更改代码，package.json中的地址就引用自己Git仓库中的地址。 使用一些第三方库的时候，有时因为第三方库并不是一直在维护的，有可能集成进去，会有 sdk 兼容问题，所以要把sdk版本改为和自己项目中的一致，也可以fork到自己的仓库中，避免每次修改。 2.react-native-camera 集成问题实现扫码安装react-native-camera之后，会出现错误，我通过这个找到了解决办法。(PS: 最好从官方文档看教程，我之前就是在网上搜的教程，但是已经过时了，这样就浪费时间找问题出在哪，网上的教程作为一个参考点就行)但是最后这个库实现的扫码，速度没有达到我们的要求(正常手机扫码速度还可以，但是我们要在性能很差的平板上快速扫码就有点难度了)，所以放弃了这种方式，最后使用PDA扫码和集成红外摄像头扫码(通过使用java代码,以原生的方式实现，辛亏有大佬帮忙ヽ(○^㉨^)ﾉ♪) 3.react-native-ble-manager 连接蓝牙之前用的测试机是 Android5.1 的，能够正常扫描蓝牙，一直以为就这样就算正确使用这个插件连接蓝牙，但是之后用自己的手机运行app的时候，发现怎么都扫描不到蓝牙，从网上搜索得知，扫码蓝牙还需要开启位置权限 1234&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;uses-feature android:name=\"android.hardware.bluetooth_le\" android:required=\"true\"/&gt; 需要加入这些权限，但是我查看自己的AndroidManifest.xml文件时，发现这些权限已经加上去了。原来，在Android6之后，权限不仅要在清单文件AndroidManifest.xml里面申请,还有单独调用api，去让用户选择是否同意你申请这个权限。 123456789101112131415161718192021222324252627282930313233343536373839_checkLocation =()=&gt;&#123; if(Platform.OS === 'ios')&#123; return false; &#125; const granted = PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION) granted.then((data) =&gt; &#123; console.log('data----', data) if (!data) &#123; this.requestLocationPermission() &#125; &#125;).catch((err) =&gt; &#123; console.log('err---------', err.toString()) &#125;) &#125; //申请地址权限 async requestLocationPermission() &#123; try &#123; const granted = await PermissionsAndroid.request( PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION, &#123; //第一次请求拒绝后提示用户你为什么要这个权限 'title': '是否允许地址查询权限', 'message': '此权限会造成系统异常，请允许', buttonNeutral: '等会再问我', buttonNegative: '不行', buttonPositive: '好吧', &#125; ) if (granted === PermissionsAndroid.RESULTS.GRANTED) &#123; console.log(\"你已获取了定位权限\") &#125; else &#123; console.log(\"获取定位权限失败,会造成系统异常\") &#125; &#125; catch (err) &#123; console.log(err.toString()) &#125; &#125; 所以可以通过以上代码，获取位置权限。 4.native-echarts 经常加载不出因为对echarts很熟悉，所以要在react-native绘制图表时，就选择了使用echarts封装的native-echarts，但是这个库已经很久不维护了，所以就fork到自己的git地址中，修改了一些地方引用。 但是使用这个图表，有时候会加载不出来，我在网上搜索也并没有搜到解决办法，网上只有说在Android中显示不出来,把tpl.html文件复制到android/app/src/main/assets文件夹下。我也在交流群中问过一些人，他们好像都没有遇到类似问题，这让我很费解，也许是因为我需要实时刷新的缘故，也就没有找到解决办法了。 native-echarts中使用echarts的办法是通过Webview中引用html文件实现的，我给webview加了startInLoadingState属性，可以查看加载状态，在我实时刷新的时候，刷新次数过多，状态会一直处于加载中，就加载不出来了，不清楚是不是由于性能消耗过多，暂时没有解决。 所以就换了一个图表库，react-native-charts-wrapper,这种图表库是基于原生的，所以性能提高了很多，图表能立马加载出来，但也有一定局限性，只有八种图表，配置项也没有echarts那么多。 要使用这个图表，需要配置一些东西，在android中配置项较少，就不说了，ios中的配置可以参考这里,但其中一些知识点已经过时不需要了，所以正确步骤还是需要参照官方文档,但是官方文档没有配图，所以不懂的地方可以参考上面这个参考，有图片引导，更加易懂一点。 (PS： Charts应该使用3.3.0版本，但是git官方地址已经更新超过这个版本了，所以下载的时候一定要注意版本一致，我就是因为下载了最新的版本，所以一致对不上。这时候就体现出仔细查看官方文档的好处了ヽ(○^㉨^)ﾉ♪) 5.ios出现 Build input file cannot be found: ‘/Users/mac/Library/Developer/Xcode/DerivedData/jty-ceemylpddhxuyyegcppypjhihevw/Build/Products/Debug-iphonesimulator/jty.app/PlugIns/jtyTests.xctest/jtyTests’ 解决方法：Xcode &gt; File &gt; Workspace Settings…orXcode &gt; File &gt; Project Settings… Shared Project Settings和Per-User Project Settings 中的Build System都从New Build System (默认) 改为Legacy nuild System 6. react-native 从0.57.8升级到0.59.10，在Android中运行，出现 Could not get unknown property ‘mergeResourcesProvider’ for object of type com.android.build.gradle.internal.api.ApplicationVariantImpl. 解决方法：/android/build.gradle 改为classpath ‘com.android.tools.build:gradle:3.3.0’/android/gradle/wrapper/grale-wrapper.properties 改为 distributionUrl=https://services.gradle.org/distributions/gradle-4.10.1-all.zip 运行有可能会出错，记得清理一下缓存 cd android &amp;&amp; gradlew clean 7 Android9.0 http无法访问网络问题先说前提背景，首次使用react-native 0.60.5版本建立项目，在手机上调试的时候没有问题，打包安装在手机上出现闪退。在Android studio中Logcat上看到闪退报错信息： 7.1 .com.facebook.react.common.JavascriptException: console.assert is not a function. (In ‘console.assert(null!=o,”‘this’ is expected an Event object, but got”,n)’, ‘console.assert’ is undefined), stack:o@112:173 w@112:1841 dispatchEvent@112:5597 value@111:6095 value@111:2835 value@44:1280 value@23:3518 &lt;unknown&gt;@23:822 value@23:2772 value@23:794 value@-1解决办法：参考的 这里 添加如下信息在 index.js中 123456789101112if (!__DEV__) &#123; global.console = &#123; info: () =&gt; &#123;&#125;, log: () =&gt; &#123;&#125;, assert: () =&gt; &#123;&#125;, warn: () =&gt; &#123;&#125;, debug: () =&gt; &#123;&#125;, error: () =&gt; &#123;&#125;, time: () =&gt; &#123;&#125;, timeEnd: () =&gt; &#123;&#125;, &#125;;&#125; 通过这些操作，app不闪退了，但是页面还是没有如期显示，是因为并没有访问到网络，没有拿到后台的数据， 7.2 在网上搜索了一下，发现是Android 9会出现这个问题，我在Android 8测试了一下，发现是的，不会出现这个问题。解决方法： APP改用 https 请求 targetSdkVersion 降到27以下 在 AndroidManifest.xml 文件的 application 加入：android:usesCleartextTraffic=&quot;true&quot; 我采用的是第三种方法 8. Attempt to invoke virtual method ‘android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)’ on a null object reference使用场景：react-native 0.57.8 Android 9我在页面中，使用TextInput放入表格中的每个单元格，就出现了这个问题，其他时候是没有出现这个问题的 解决方法： 在 android/src/main/res/values/styles.xml 插入这句 1&lt;item name=\"android:editTextBackground\"&gt;@android:color/transparent&lt;/item&gt; 参考地址 9. Date 问题在debug模式下，没有问题如果不开启debugger-ui， Date.parse就获取不到数据，暂不知道原因，用的moment来处理时间 10. android.support.v4.content.FileProvider找不到问题我在使用 react-native-doc-viewer的时候遇到这个问题，因为我给项目升级了androidX,所以导致和这个库里面不兼容，(ps:同时这个库的sdk版本太旧，需要自己修改匹配自己的项目的才能打包)。 解决方法： 找到上图报错的文件夹，修改android.support.v4.content.FileProvider 为 androidx.core.content.FileProvider可以把这个库fork到自己的仓库，之后就引用自己仓库的，就不用重装依赖之后，每次都修改了 11. 点击Home键退出，再次点击桌面图标启动应用，会再次启动APP，而不是把后台程序显示出来解决方法一：可以在AndroidManifest.xml中修改 MainActivity 的 launchMode为SingleTask 1234567&lt;activity android:name=\"***.MainActivity\" android:label=\"@string/app_name\" android:configChanges=\"keyboard|keyboardHidden|orientation|screenSize\" android:windowSoftInputMode=\"adjustResize\" android:screenOrientation=\"portrait\" android:launchMode=\"singleTask\"&gt; 解决方式二： 由于 RN 的Activity 继承自 ReactActivity ,所以需要修改源码，在ReactActivity.java 的 onCreate 的方法添加,没有onCreate方法，就自己添加一个 12345678910111213141516// import android.content.Intent; //Intent//...protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (!this.isTaskRoot()) &#123; Intent mainIntent = getIntent(); String action = mainIntent.getAction(); if (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; action.equals(Intent.ACTION_MAIN)) &#123; finish(); return; &#125; &#125; &#125;// mDelegate.onCreate(savedInstanceState); //假如你之前有这个方法的话，没有就可以不写 //PS：记得在 super.onCreate() 方法之后，mDelegate.onCreate之前执行有效 &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"React native","slug":"React-native","permalink":"http://blog.eyes487.top/tags/React-native/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"理解浏览器和Node中的事件循环(EventLoop)","slug":"eventloop","date":"2019-10-20T00:00:00.000Z","updated":"2020-07-23T12:22:45.189Z","comments":true,"path":"2019/10/20/eventloop.html","link":"","permalink":"http://blog.eyes487.top/2019/10/20/eventloop.html","excerpt":"","text":"看过很多类似文章之后，想总结了一下关键点记录下来，方便之后回顾。了解EventLoop可以用来分析一些异步次序的问题，同时还能了解一些浏览器和Node的内部机制。 前言: 为什么是事件循环 网景公司在1994年发明了第一个浏览器，之前网速都是非常慢的，所以等服务器反应可能需要很久，假如一个场景，表单填写，填写完成之后，等很久浏览器反应之后发现表单填写时错误的，这样多试几次之后，可能人都是崩溃的，所以网景这个公司花了7天的时间，设计了javascript，用来帮助用户可以在浏览器端做一些基础的校验，来减少交互的过程。可以看出，js是创建出来为了辅助网景公司销售他们的浏览器。根据标准中对时间循环的定义描述，我们可以发现事件循环本质上是user agent(如浏览器端)用于协调用户交互（鼠标、键盘)、脚本（如js）、渲染（如HTML DOM、css样式）、网络等行为的一个机制。与其说是js提供了事件循环，不如说是嵌入js的user agent 需要事件循环来与多种事件源交互。 1.浏览器中的EventLoop1.1 js引擎的事件循环机制 js是一门单线程、无阻塞的脚本语言。 执行js文件的时候，会按照从上到下的顺序，把其中的同步代码加入执行栈中，然后按照顺序执行执行栈中的代码。 执行异步代码的时候，他不会立即返回结果，会将这个异步事件挂着，当异步事件返回结果的时候，就会把这个事件加入事件队列 他不会立即执行，直到执行栈中的所有任务都执行完毕，主线程处于闲置状态的时候，主线程就会去查询事件队列是都有任务 有的话,就从中取出排在第一位的事件，把这个事件的回调函数加入执行栈，然后执行其中的代码 如此反复，就形成了无线的循环，这个过程就叫做 事件循环 1.2 事件队列事件队列也分为 宏任务（macrotask) 和 微任务（microtask） 常见属于宏任务的有： script(整体代码) setTimeout / setInterval 事件回调 网络请求等，XHR 回调 history.back 常见属于微任务的有： Promise MutaionObserver，是H5的新特性 Object.observe(废弃) 在事件循环中，每进行一次循环操作称为tick 在此次tick中最先进入的执行栈的任务(第一次是script代码)执行一次，执行完毕 在执行栈为空的时候，主线程就会查看微任务列表是否为空 存在微任务，就会不停地执行，直至微任务清空 执行UI render 下一次tick，执行任务队列排在第一的宏任务，执行完毕，可能会产生微任务 是否有微任务，执行直至清空队列 执行UI render 主线程重复执行上述步骤 浏览器完成一个宏任务，在下一个宏任务执行开始前，会对页面进行重新渲染。如果存在微任务，浏览器会清空微任务之后再重新渲染。 下面这张图可以说明流程 1.3 示例12345678910111213141516171819202122232425262728293031console.log(1);setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;);&#125;);new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(5)&#125;).then((data) =&gt; &#123; console.log(data); Promise.resolve().then(() =&gt; &#123; console.log(6) &#125;).then(() =&gt; &#123; console.log(7) setTimeout(() =&gt; &#123; console.log(8) &#125;, 0); &#125;);&#125;)setTimeout(() =&gt; &#123; console.log(9);&#125;)console.log(10); 正确的打印顺序是: 1234567891014105672398 分析，第一步： 先打印1 setTimeout加入事件队列（宏任务) 接着打印 4，promise的返回的回调加入事件队列（微任务） setTimeout加入事件队列（宏任务） 接着打印10 第二步： 微任务在宏任务之前执行，打印 5 此次微任务又产生了微任务，会在宏任务之前执行，接着打印 6 打印 7 把setTimeOut 加入事件队列(宏任务) 第三步： 此时，已经不存在微任务，按照顺序执行宏任务，打印2 执行时，又产生了一个微任务，只能先执行这个微任务，打印3 微任务执行完毕，按照顺序，执行宏任务，打印9 打印 8 所以，如果执行任务的时候不断的产生了微任务，那之后的宏任务就没办法执行了 2.Node中的EventLoopNode的异步语法比浏览器更复杂，它可以和内核对话，所以它使用了libuv库来实现EventLoop，这个库负责各种回调函数的执行时间。 node中有一个注意的点： 在node v11以下，它的执行顺序是先清空宏任务队列，然后在清空微任务队列，这样保证所有队列都有相等机会执行，这和浏览器执行顺序不一样 但是，在node v11开始，就修复了这个问题，执行顺序就和浏览器一致了，先执行一个宏任务，就清空微任务队列 2.1 Node中提供了四个定时器 setTimeout() setInterval() setImmediate() process.nextTick()上面两个语言标准，后两个是Node中独有的。看看几个定时器在Node中的运行顺序:123456789101112setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))();//node index.js//5//3//4//1//2 Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环,而本轮循环一定早于次轮循环执行。 所有同步任务执行完之后就是异步任务，process.nextTick是异步任务中最早执行的，如果想要异步任务尽快执行，就使用process.nextTick。而promise的回调函数会被添加于微任务队列，追加在process.nextTick之后，也存在于本轮循环，只有等本轮循环(当前队列)执行完之后，才会进入下一队列。 2.2 事件循环的六个阶段事件循环会按照顺序，反复地执行。每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。 2.2.1 timers这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。 2.2.2 I/O callbacks除了以下操作的回调函数，其他回调函数都在这个阶段执行 setTimeout()和setInterval()的回调函数 setImmediate()的回调函数 用于关闭请求的回调函数，比如socket.on(‘close’, …) 根据libuv的文档，一些应该在上轮循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。 2.2.3 idle, prepare该阶段只供 libuv 内部调用，这里可以忽略。 2.2.4 Poll这个阶段是轮询时间，用于等待还未返回的 I/O事件，比如服务器的回应、用户移动鼠标等等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。 2.2.5 check该阶段执行setImmediate()的回调函数。 2.2.6 close callbacks该阶段执行关闭请求的回调函数，比如socket.on(&#39;close&#39;, ...)。 2.3 示例来自官方文档的一个示例 1234567891011121314151617const fs = require('fs');const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile('test.js', () =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;); 分析：第一轮 没有到期的定时器 也没有刻意执行的 I/O 回调函数 内核读取文件 Poll阶段，等待内核读取文件的结果，不会操作100ms，在定时器到期之前就会得到结果 第二轮 没有到期的定时器 有刻意执行的回调函数，进入I/O callbacks阶段，这个回调函数需要200ms，在执行到一半的时候，100ms定时器到期，但是必须等到这个回调函数执行完，才会离开这个阶段 第三轮 有了到期的定时器，所以会在timers阶段执行定时器，输出结果大概200多毫秒 2.4 setTimeout 和 setImmediate由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。 12345setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));//结果不确定//1 2 或者 2 1 因为 setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行，进入事件循环，有可能到了1毫秒，有可能没有，这取决于系统当时的情况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。 但是，下面代码一定是2 1 123456const fs = require('fs');fs.readFile('test.js', () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); 代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。 ————-如果以上内容有不对的地方，还请大家指正———— Node中的事件循环参考《Node 定时器详解》《不要混淆nodejs和浏览器中的event loop》","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Js","slug":"Js","permalink":"http://blog.eyes487.top/tags/Js/"},{"name":"Node","slug":"Node","permalink":"http://blog.eyes487.top/tags/Node/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"手写DOM-Diff算法","slug":"dom-diff-algorithnm","date":"2019-10-13T00:00:00.000Z","updated":"2020-07-23T12:22:45.189Z","comments":true,"path":"2019/10/13/dom-diff-algorithnm.html","link":"","permalink":"http://blog.eyes487.top/2019/10/13/dom-diff-algorithnm.html","excerpt":"","text":"接触React已经两年多了,提起React，总是免不了要和Vue做一番对比，两个框架都使用了虚拟DOM。那今天就了解一下什么是虚拟DOM，虚拟DOM的实现和使用吧。 1.虚拟DOM1.1 什么是虚拟DOM Virtual DOM 也就是虚拟节点。它通过js的Object对象模拟真实的DOM节点，然后在通过特定的 render 方法将其渲染成真实的DOM。在更改元素的时候并不是修改真正的DOM，而是通过虚拟DOM进行Diff运算，得到最小的差异生成补丁（Patch）应用到真实DOM中。 1234567//createElemnt =&gt;( type, props, children)createElement('ul',&#123; class: 'list'&#125;,[ createElemnt('li', &#123;class: 'item'&#125;, ['React']), createElemnt('li', &#123;class: 'item'&#125;, ['Vue']), createElemnt('li', &#123;class: 'item'&#125;, ['Angular']) ]) 虚拟DOM就是通过上面这样一个方法，创建的一个js对象，如下： 1.2 创建虚拟DOM可以通过create-react-app快速构建一个项目下面我们就来实现这个createElement方法,创建一个element.js 和 index.js 1234567891011121314//element.jsclass Element&#123; constructor(type,props,children)&#123; this.type = type; this.props = props; this.children = children; &#125;&#125;function createElement(type,props,children)&#123; return new Element(type,props,children)&#125;export &#123;createElement&#125; 12345678910//index.jsimport &#123;createElement&#125; from './element';let virtualDom = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['ANgular']),])console.log(virtualDom) //===&gt;打印出虚拟DOM 如上图 图1 1.3 渲染真实DOM通过 render 方法将虚拟DOM转化为真实DOM ,在通过renderDOM把真实DOM元素插入页面中 1234567891011121314151617181920212223242526272829303132//element.js 在element.js中添加如下方法function setAttr(node,key,value)&#123; switch(key)&#123; case 'value': if(node.tagName.toUpperCase() === \"INPUT\" ||node.tagName.toUpperCase === \"TEXTAREA\")&#123; node.value = value; &#125;else&#123; node.setAttribute(key,value); &#125; break; case 'style': node.style.cssText = value;break; //可能还有其他情况... default: node.setAttribute(key,value); &#125;&#125;//render方法可以将v-dom转化为真实domfunction render(eleObj)&#123; let el = document.createElement(eleObj.type); for(let key in eleObj.props)&#123; setAttr(el,key,eleObj.props[key]); //设置属性的方法 &#125; eleObj.children.forEach(child=&gt;&#123; //遍历子节点，如果是虚拟dom继续渲染，否则代表是文本节点 child = (child instanceof Element)?render(child) : document.createTextNode(child); el.appendChild(child); //放入父节点 &#125;) return el;&#125;//把真实dom插入目标源function renderDom(el,target)&#123; target.appendChild(el);&#125;export &#123;createElement,render,renderDom&#125;; 12345678910111213//index.jsimport &#123;createElement,render,renderDom&#125; from './element';let virtualDom = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['ANgular']),])let el = render(virtualDom)console.log(virtualDom)console.log(el);renderDom(el,window.root) 这样界面上就生成了一个无序列表 2. DOM-Diff2.1 DOM-Diff的作用比较两个虚拟DOM的区别，根据两个虚拟DOM创建出补丁，描述改变的内容，将这个补丁用来更新DOM 2.2 DOM-Diff比较时遵循的原则 只会比较平级节点，不会跨级比较 比较平级节点时，如发现节点不存在，会将该节点及其子节点完全删掉，节点类型变了会直接生成新的节点 比较平级节点时，如果只是两个节点产生位置变化，那么会复用此节点，将两个节点交换位置即可，通过给同级列表元素添加key值实现 DOM-Diff遵循 树的先序深度优先遍历 2.3 实现Diff算法可以先定义一些规则: 当节点类型相同，比较属性是否相同，如果不同，产生一个补丁包 {type:’ATTRs’,attrs:{class: ‘xxx’}} 当新dom节点不存在的时候，直接删除，补丁包 {type: ‘REMOVE’,index: xxx} 当节点类型不相同，就替换节点 {type: ‘REPLACE’,newNode: xxx} 当只是文本变化，就变更文本 {type: ‘TEXT’, text: ‘xxxx’}… 创建一个diff.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//diff.jsconst ATTRS = 'ATTRS';const TEXT = 'TEXT';const REMOVE = 'REMOVE';const REPLACE = 'REPLACE';let Index = 0;function diffAttr(oldAttrs,newAttrs)&#123; let patch = &#123;&#125;; for(let key in oldAttrs)&#123; if(oldAttrs[key] !== newAttrs[key])&#123; patch[key] = newAttrs[key] &#125; &#125; for(let key in newAttrs)&#123; if(!oldAttrs.hasOwnProperty(key))&#123; patch[key] = newAttrs[key] &#125; &#125; return patch;&#125;function diffChildren(oldChildren,newChildren,patches)&#123; oldChildren.forEach((child,idx)=&gt;&#123; recursion(child, newChildren[idx],++Index,patches) &#125;)&#125;function isString(node)&#123; return typeof node === \"string\";&#125;function recursion(oldNode,newNode,index,patches)&#123; let currentPatch = []; //每个元素都有一个补丁对象 if(!newNode)&#123; currentPatch.push(&#123;type: REMOVE, index&#125;) &#125;else if(isString(oldNode)&amp;&amp;isString(newNode))&#123; if(oldNode !== newNode)&#123; currentPatch.push(&#123;type: TEXT, text: newNode&#125;) &#125; &#125;else if(oldNode.type === newNode.type)&#123; let attrs = diffAttr(oldNode.props,newNode.props) if(Object.keys(attrs).length&gt;0)&#123; currentPatch.push(&#123;type: ATTRS,attrs&#125;) &#125; //如果有子节点，遍历子节点 diffChildren(oldNode.children,newNode.children,patches); &#125;else&#123; //说明节点被替换了 currentPatch.push(&#123;type: REPLACE, newNode: newNode&#125;) &#125; if(currentPatch.length&gt;0)&#123; // 将元素和补丁对应起来，放入大的补丁包中 patches[index] = currentPatch; &#125;&#125;function Diff(oldTree,newTree)&#123; let patches = &#123;&#125;; //递归树 比较后的结果放入补丁包中 recursion(oldTree,newTree,Index,patches); return patches;&#125;export default Diff; 1234567891011121314151617//index.jsimport &#123;createElement,render,renderDom&#125; from './element';import Diff from './diff';let virtualDom1 = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['Angular']),])let virtualDom2 = createElement('ul',&#123;class: 'list2',id: 6&#125;,[ createElement('li',&#123;class: 'item'&#125;,['Html']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('div',&#123;class: 'item'&#125;,['Js']),])let patches = Diff(virtualDom1,virtualDom2)console.log(patches) //===&gt;打印出补丁包 补丁包如下 图2 2.4 把补丁包应用到真实DOM上创建一个patch.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445//patch.jsimport &#123; render ,Element,setAttr&#125; from \"./element\";let allPatches;let index = 0;//默认打补丁的序号function Patch(node,patches)&#123; allPatches = patches; walk(node) //给某个元素打补丁&#125;function doPatch(node,patches)&#123; patches.forEach(patch=&gt;&#123; switch(patch.type)&#123; case 'ATTRS': for(let key in patch.attrs)&#123; let value = patch.attrs[key]; if(value)&#123; setAttr(node,key,value) &#125;else&#123; node.removeAttribute(key) &#125; &#125; break; case 'TEXT': node.textContent = patch.text; break; case 'REPLACE': let newNode = (patch.newNode instanceof Element)? render(patch.newNode): document.createTextNode(patch.newNode); node.parentNode.replaceChild(newNode,node); break; case 'REMOVE': console.log('remove',node.parentNode); node.parentNode.removeChild(node); break; &#125; &#125;)&#125;function walk(node)&#123; let currentPatch = allPatches[index++]; let childNodes = node.childNodes; childNodes.forEach(child=&gt;walk(child)) if(currentPatch)&#123; doPatch(node,currentPatch) &#125;&#125;export default Patch; 1234567891011121314151617181920//index.jsimport &#123;createElement,render,renderDom&#125; from './element';import Diff from './diff';import Patch from './patch';let virtualDom1 = createElement('ul',&#123;class: 'list'&#125;,[ createElement('li',&#123;class: 'item'&#125;,['React']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('li',&#123;class: 'item'&#125;,['Angular']),])let virtualDom2 = createElement('ul',&#123;class: 'list2',id: 6&#125;,[ createElement('li',&#123;class: 'item'&#125;,['Html']), createElement('li',&#123;class: 'item'&#125;,['Vue']), createElement('div',&#123;class: 'item'&#125;,['Js']),])let el = render(virtualDom1)renderDom(el,window.root)let patches = Diff(virtualDom1,virtualDom2); //对比两个虚拟DOM的差异Patch(el,patches); //把差异应用到元素节点 这样就完成了一个简易的DOM-Diff算法，当然还有很多情况没有考虑到，比如根据列表根据key值交换位置…","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://blog.eyes487.top/tags/React/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://blog.eyes487.top/tags/虚拟DOM/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"简单请求和复杂请求","slug":"simple-and-complex-requests","date":"2019-10-08T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2019/10/08/simple-and-complex-requests.html","link":"","permalink":"http://blog.eyes487.top/2019/10/08/simple-and-complex-requests.html","excerpt":"","text":"当一个资源从与该资源本身所在的服务器不同的 域、协议 或 端口 请求一个资源时，资源会发起一个跨域 HTTP 请求。跨域资源共享(CORS) 是一种解决跨域的机制，它使用额外的 HTTP 头，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，那些可能对服务器数据产生副作用的 HTTP 请求方法 (复杂请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。 1.简单请求/复杂请求同时满足下列三大条件，就属于简单请求 请求方式只能是，get、post、head http请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID Content-Type只能取：application/x-www-form-urlencoded、nultipart/form-data、text/plain 其他请求都属于属于非简单请求 2.预检请求（Preflighted Requests）Preflighted Requests是CORS中一种透明服务器验证机制。预检请求首先需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，其目的就是为了判断实际发送的请求是否是安全的。 简单跨域请求不会发送options（预检请求），复杂跨域请求会发送options 3.如何避免发送options请求 如何避免发送options请求，就是尽可能使用简单请求啦~ 还可以通过给服务器设置请求头 Access-Control-Max-Age来避免发送options请求，浏览器一般会有一个默认值，但是都不长久，可以自己设置 1Access-Control-Max-Age: 600 //即预检请求的结果缓存10分钟 Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。也就是说，如果设置了10分钟的缓存，在10分钟内，所有请求第一次会产生options请求，第二次以及第二次以后就只发送真正的请求了。 ————-如果以上内容有不对的地方，还请大家指正————","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://blog.eyes487.top/tags/Http/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"实现MVVM原理","slug":"mvvm-principle","date":"2019-09-10T00:00:00.000Z","updated":"2020-07-23T12:22:45.193Z","comments":true,"path":"2019/09/10/mvvm-principle.html","link":"","permalink":"http://blog.eyes487.top/2019/09/10/mvvm-principle.html","excerpt":"","text":"1.什么是MVVM简单来说，MVVM就是一种模式，把数据和视图进行关联的一种模式。最常见的就是应用于Vue中，实现了数据绑定和视图渲染，Vue 最独特的特性之一，是其非侵入性的响应式系统，当数据变化时，视图会做出相应的更新，当视图变化，数据也会相应更新，主要体现在Vue中双向绑定，主要通过表单元素设置v-model属性实现双向绑定。 放一张从网上找的图 Vue中一般这样引用 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data:&#123; message:'hello world' &#125; &#125;)&lt;/script&gt; 2.响应式原理分析 1、首先通过new Vue()执行初始化，对数据进行数据劫持 Observer，同时执行编译模板 Compile 2、在Observer中通过 Object.defineProperty / Proxy对数据进行劫持，其中有 get 和 set方法 ,在get中为每个key值创建一个Dep(依赖收集) 3、在 Compile 中执行模板编译的时候，可以知道哪些数据是动态绑定的，为每个数据创建一个Watcher，里面放的是数据的更新方法(Updater) 4、在创建这个Watcher的时候，可以通过Dep.target = this,把Watcher先保存下来，触发get方法把Watcher收进Dep中 ，通过dep.addSub()方法，在置空Dep.target 5、依赖收集完毕，在set方法中，设置新值的时候会触发set方法,设置dep.notify()通知所有更新方法更新,就完成了整个响应过程 所以数据key值，Dep, Watcher 是一对一对多的关系，每个数据值都有一个Dep(相当于管家)，里面管理着多个Watcher，数据在页面上引用一次，就会产生一个Watcher PS: vue2中已经不采用这种方式了，每个组件会生成一个Watcher，组件中的任何key变化都会去触发Watcher的更新函数，所有就引入了虚拟dom的概念，来判断最小差异，之后会在Vue源码解析中介绍。 3.Vue中的数据响应化实现要实现数据双向绑定主要有三个核心点： 模板的编译 数据劫持,观察数据变化 watcher最后通过入口函数MVVM，整合三个核心点 首先自己创建一个MVVM.html 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message.a\"/&gt; &#123;&#123;message.a&#125;&#125; &lt;/div&gt; //这里会引用自己写的一些方法... &lt;script src=\"watcher.js\"&gt;&lt;/script&gt; &lt;script src=\"observer.js\"&gt;&lt;/script&gt; &lt;script src=\"compile.js\"&gt;&lt;/script&gt; &lt;script src=\"MVVM.js\"&gt;&lt;/script&gt; &lt;script&gt; let vm = new MVVM(&#123; el: '#app', //这里可以传字符串，也可以传document元素节点 data:&#123; message: &#123; a: 'hello World!' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 创建一个MVVM.js文件 123456789101112131415161718192021222324252627282930//MVVM.jsclass MVVM&#123; constructor(options)&#123; //把可用的东西挂载在实例上 this.$el = options.el; this.$data = options.data; //如果有要编译的模板 if(this.$el)&#123; //数据劫持，把对象的所有属性改为set和get方法 new Observer(this.$data); this.proxyData(this.$data); //用数据和元素进行编译 new Compile(this.$el,this) &#125; &#125; //把数据代理到this上，可以直接通过this取 proxyData(data)&#123; Object.keys(data).forEach(key=&gt;&#123; Object.defineProperty(this,key,&#123; get()&#123; return data[key] &#125;, set(newValue)&#123; data[key] = newValue &#125; &#125;) &#125;) &#125;&#125; 下面就开始用代码一步步实现MVVM原理。 2.1 模板编译新建compile.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140class Compile&#123; constructor(el,vm)&#123; this.el = this.isElementNode(el)?el:document.querySelector(el); this.vm = vm; if(this.el)&#123; //开始编译 //1.先把真是dom移入内存中Fragment（性能） let fragment = this.node2Fragment(this.el); //2.编译 =》提取想要的元素节点 v-model和文本节点&#123;&#123;&#125;&#125; this.compile(fragment) //把编译后的Fragment移回页面 this.el.appendChild(fragment) &#125; &#125; /** * * @param &#123;辅助方法&#125; node */ //判断是否是元素节点 isElementNode(node)&#123; return node.nodeType === 1; &#125; //是不是指令 isDirective(name)&#123; return name.includes('v-') &#125; /** * 核心方法 * @param &#123;*&#125; el */ compileElement(node)&#123; //带v-model let attrs = node.attributes;//取出当前节点属性 Array.from(attrs).forEach(attr=&gt;&#123; //判断属性名字是否包含v- let attrName = attr.name; if(this.isDirective(attrName))&#123; //取到对应的值放到节点中 let expr = attr.value; let [,type] = attrName.split('-'); //node this.vm.$data CompileUtil[type](node,this.vm,expr) &#125; &#125;) &#125; compileText(node)&#123; //带&#123;&#123;&#125;&#125; let expr = node.textContent; //取文本中的内容 let reg = /\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g; if(reg.test(expr))&#123; //node this.vm.$data text CompileUtil['text'](node,this.vm,expr) &#125; &#125; compile(fragment)&#123; let childNodes = fragment.childNodes; Array.from(childNodes).forEach(node=&gt;&#123; if(this.isElementNode(node))&#123; //是元素节点,编辑元素 this.compileElement(node); //元素节点中可能还有节点 this.compile(node) &#125;else&#123; //文本节点,编译节点 this.compileText(node); &#125; &#125;) &#125; node2Fragment(el)&#123; let fragment = document.createDocumentFragment(); let firstChild; while(firstChild = el.firstChild)&#123; fragment.appendChild(firstChild); &#125; return fragment; &#125;&#125;CompileUtil =&#123; getVal(vm,expr)&#123;//获取实例上对应的数据 expr = expr.split('.'); //\"message.a\" =&gt; [message,a] return expr.reduce((prev,next)=&gt;&#123; //vm.$data.a return prev[next] &#125;,vm.$data); &#125;, setVal(vm,expr,value)&#123; expr = expr.split('.'); //收敛 return expr.reduce((prev,next,currentIndex)=&gt;&#123; if(currentIndex === expr.length -1)&#123; return prev[next] = value; &#125; return prev[next] &#125;,vm.$data) &#125;, getTextVal(vm,expr)&#123; return expr.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g,(...arguements)=&gt;&#123; return this.getVal(vm,arguements[1]) &#125;) &#125;, text(node,vm,expr)&#123; //文本处理 let updateFn = this.updater['textUpdater']; expr.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g,(...arguements)=&gt;&#123; new Watcher(vm,arguements[1],newValue=&gt;&#123; //如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容 updateFn &amp;&amp; updateFn(node,this.getTextVal(vm,expr)) &#125;) &#125;) updateFn &amp;&amp; updateFn(node,this.getTextVal(vm,expr)) &#125;, model(node,vm,expr)&#123; //输入框处理 let updateFn = this.updater['modelUpdater']; //这里加一个监控，数据变化了。应该调用这个watch的cb new Watcher(vm,expr,newValue=&gt;&#123; updateFn &amp;&amp; updateFn(node,this.getVal(vm,expr)) &#125;) node.addEventListener('input',(e)=&gt;&#123; let newValue = e.target.value; this.setVal(vm,expr,newValue) &#125;) updateFn &amp;&amp; updateFn(node,this.getVal(vm,expr)) &#125;, updater:&#123; //文本更新 textUpdater(node,value)&#123; node.textContent = value; &#125;, //输入框更新 modelUpdater(node,value)&#123; node.value = value; &#125; &#125;&#125; 2.2 数据劫持（Observer）新建observer.js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Observer&#123; constructor(data)&#123; this.observe(data) &#125; observe(data)&#123; //要对这个data数据将原有的属性改成set和get的形式 if(!data || typeof data !== \"object\")&#123; return &#125; //将所有数据一一劫持，先获取到data的key和value Object.keys(data).forEach(key=&gt;&#123; //劫持 this.defineReactive(data,key,data[key]); this.observe(data[key]);//深度递归劫持 &#125;) &#125; //定义响应式 defineReactive(obj,key,value)&#123; let that = this; let dep = new Dep(); Object.defineProperty(obj,key,&#123; enumerable: true, //可枚举 configurable: true, //可修改 get()&#123; //当取值的时候调用的方法 // 收集依赖 在创建Watcher的时候，会将watcher赋值给Dep.target,所以可以将他加入依赖中 Dep.target &amp;&amp; dep.addSub(Dep.target) return value; &#125;, set(newValue)&#123; //当给data属性中设置值的时候， 更改获取的属性的值 if(newValue != value)&#123; that.observe(newValue); value = newValue; dep.notify(); //通知所有人，数据更新了 &#125; &#125; &#125;) &#125;&#125;class Dep&#123; constructor()&#123; //订阅的数组 this.subs = []; &#125; addSub(watcher)&#123; this.subs.push(watcher) &#125; notify()&#123; this.subs.forEach(watcher=&gt;watcher.update()) &#125;&#125; 2.3 watcher新建watcher.js文件,给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法 1234567891011121314151617181920212223242526272829class Watcher&#123; constructor(vm,expr,cb)&#123; this.vm = vm; this.expr = expr; this.cb = cb; //先获取旧值 this.value = this.get(); &#125; getVal(vm,expr)&#123;//获取实例上对应的数据 expr = expr.split('.'); //\"message.a\" =&gt; [message,a] return expr.reduce((prev,next)=&gt;&#123; //vm.$data.a return prev[next] &#125;,vm.$data); &#125; get()&#123; Dep.target = this; let value = this.getVal(this.vm,this.expr); Dep.target = null; return value; &#125; update()&#123; let newValue = this.getVal(this.vm,this.expr); let oldValue = this.value; if(newValue != oldValue)&#123; this.cb(newValue) &#125; &#125;&#125; 4. Proxy在Vue3.0中将会使用Proxy实现数据的双向绑定，Proxy 是ES6 中新增的功能，它可以用来自定义对象中的操作。 1234//语法let p = new Proxy(target, handler);//target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。//handlew 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 数据劫持的简单实现 1234567891011121314151617181920212223242526function render() &#123; console.log('模拟视图的更新')&#125;let obj = &#123; message: 'hello world',&#125;let handler = &#123; get(target, key) &#123; // 如果取的值是对象就在对这个对象进行数据劫持 if (typeof target[key] == 'object' &amp;&amp; target[key] !== null) &#123; return new Proxy(target[key], handler) &#125; return Reflect.get(target, key) &#125;, set(target, key, value) &#123; if (key === 'length') return true render(); return Reflect.set(target, key, value) &#125;&#125;let proxy = new Proxy(obj, handler)console.log(proxy.message) // hello worldproxy.message = 'my name is eyes487' // 支持新增属性console.log(proxy.message) // 模拟视图的更新 my name is eyes487 用这种方法的优点： defineProperty只能监听某个属性，不能对全对象监听 不会对源对象进行污染，代理返回了一个新的对象 可以省去循环，提升效率 可以监听数组，不用再去对单独的随想做特异性操作 代码可以精简很多 但目前proxy兼容性还不是很好* 源码地址","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.eyes487.top/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://blog.eyes487.top/tags/MVVM/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]},{"title":"浅谈this指向","slug":"analyse-of-this","date":"2019-08-24T00:00:00.000Z","updated":"2020-07-23T12:22:45.189Z","comments":true,"path":"2019/08/24/analyse-of-this.html","link":"","permalink":"http://blog.eyes487.top/2019/08/24/analyse-of-this.html","excerpt":"","text":"本文出自 《你不知道的js》，看过之后总是容易忘记，所以总结记录一下。 1.this到底是什么 this是在 运行时 绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数调用时，会创建一个活动记录（也称执行上下文）。这个记录会包含函数在哪里调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到。 2.this绑定规则2.1 默认绑定非严格模式下，指向全局对象Windows 1234567891011121314151617181920//严格模式function foo()&#123; \"use strict\"; console.log(this.a);&#125;var a = 2;foo()// TypeError: this is undefinedfunction foo()&#123; console.log(this.a);&#125;var a = 2;(function()&#123; \"use strict\"; foo()//2&#125;) 2.2 隐式绑定12345678function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;obj.foo(); //2 无论是直接在obj中定义还是先定义在添加为引用类型，这个函数严格来说都不属于obj对象。然而，调用位置会使用obj上下文来引用函数，因此可以说函数被调用时obj对象拥有它或包含它。 1234567891011//隐式丢失function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;var bar = obj.foo; // 函数别名var a = \"ooop\"; //a是全局对象的属性bar(); // \"ooop\" 虽然bar是obj.foo的一个引用,但是实际上，它引用的是foo函数本身，所以此处应用了默认绑定。 参数传递也是一种隐式复制，传入函数时也会被隐式赋值 12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;var a = \"ooop\"; //a是全局对象的属性setTimeout(obj.foo, 100); //\"ooop\" 2.3 显式绑定Js提供的绝大部分函数以及你自己所创建的函数都可以使用call()和apply()方法 1234567function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2,&#125;foo.call(obj); //2 这样还是会存在丢失绑定的问题 硬绑定（不会丢失绑定） 1234567891011121314151617181920212223242526function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2,&#125;var bar = function()&#123; foo.call(obj);&#125;bar(); //2setTimeout(bar,100); //2bar.call(Window); //2 硬绑定的bar不可能在修改它的this//-----使用bind-----------function foo(something)&#123; console.log(this.a, something); return thi.a + something;&#125;var obj =&#123; a: 2&#125;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); //5 2.4 new 绑定 首先我们重新定义一下JavaScript中的 “构造函数”。在js中，构造函数只是一些使用new操作符时被调用的函数。他们并不会属于某个类，也不会实例化一个类。实际上，他们甚至都不能说是一种特殊的函数类型，他们只是被new操作符调用的普通函数。 12345function foo()&#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); //2 3.优先级 函数是否在new中调用（new 绑定)?如果是的话this绑定的是新创建的对象。var bar = new foo(); 函数是否通过call，apply（显示绑定）或者硬绑定调用？ 如果是的话，this绑定的是指定的对象var bar = foo.call(obj); 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。var bar = obj.foo(); 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象var bar = foo(); 就是这样。对于正常的函数调用来说，理解了这些知识点就可以明白this的绑定原理了。不过，凡事都有列外 4.绑定例外4.1 如果把null或者undefined最为this的绑定对象传入call、apply或者bind，这些纸在调用时会被忽略。 一种非常常见的做法是使用apply（）来展开一个数组，并当做参数传入一个函数。类似地，bind（）可以对函数进行柯里化（预先设置一些参数） 123456789function foo(a,b)&#123; console.log(\"a:\" + a+ \",b:\"+ b+);&#125;//把数组展开成参数foo.apply(null,[2,3]); //a:2, b:3//使用bind（）进行柯里化var bar = foo.bind(null,2);bar(3); //a:2 , b:3 然而，总是使用null来忽略this绑定会产生一种副作用 更安全的做法是传入一个特殊对象，把this绑定到这个特殊对象不会对程序产生副作用 123456789101112function foo(a,b)&#123; console.log(\"a:\" + a+ \",b:\"+ b+);&#125;//我们的DMZ空对象var の = Object.create(null);//把数组展开成参数foo.apply(null,[2,3]); //a:2, b:3//使用bind（）进行柯里化var bar = foo.bind(の,2);bar(3); //a:2 , b:3 4.2 间接引用调用这个函数会应用默认绑定规则 12o.foo(); //3(p.foo = o.foo)(); //2 4.3 软绑定 softBind()把this绑定到指定对象上后，但是可以使用隐式绑定和显示绑定来更改this 123456789101112131415161718function foo()&#123; console.log(\"name: \"+this.name);&#125;var obj1=&#123;name:\"obj1\"&#125;, obj2=&#123;name:\"obj2\"&#125;, obj3=&#123;name:\"obj3\"&#125;;var fooOBJ=foo.softBind(obj1);fooOBJ();//\"name: obj1\" 在这里软绑定生效了，成功修改了this的指向，将this绑定到了obj1上 obj2.foo=foo.softBind(obj1);obj2.foo();//\"name: obj2\" 在这里软绑定的this指向成功被隐式绑定修改了，绑定到了obj2上 fooOBJ.call(obj3);//\"name: obj3\" 在这里软绑定的this指向成功被硬绑定修改了，绑定到了obj3上 setTimeout(obj2.foo,1000);//\"name: obj1\"/*回调函数相当于一个隐式的传参，如果没有软绑定的话，这里将会应用默认绑定将this绑定到全局环境上，但有软绑定，这里this还是指向obj1*/ 5.this词法 ES6中有一种特殊函数类型：箭头函数 箭头函数会捕获调用函数时的this，一经绑定无法修改（new也不行） 如果经常编写this风格的代码，但是绝大部分时候都会使用 self = this 或者 箭头函数 来否定this机制，那或许应该： 只使用词法作用域并完全抛弃错误this风格的代码 完全才用this风格，在必要时使用 bind（），尽量避免使用 self = this 和 箭头函数","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}],"tags":[{"name":"Js","slug":"Js","permalink":"http://blog.eyes487.top/tags/Js/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://blog.eyes487.top/categories/前端/"}]}]}