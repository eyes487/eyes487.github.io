<!DOCTYPE HTML>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="eyes487的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <meta name="google-site-verification" content="kh2qynWK0TEziuoSJmSB1lNTaVoVXykqpgCSyD1FtWA">
    <link rel="dns-prefetch" href="http://blog.eyes487.top">
    <!--SEO-->

<meta name="keywords" content="Js,Node">


<meta name="description" content="看过很多类似文章之后，想总结了一下关键点记录下来，方便之后回顾。了解EventLoop可以用来分析一些异步次序的问题，同时还能了解一些浏览器和Node的内部机制。
前言: 为什么是事件循环
网景...">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>
    
    理解浏览器和Node中的事件循环(EventLoop) |
    
    eyes487的博客
</title>

<link rel="alternate" href="/atom.xml" title="eyes487的博客" type="application/atom+xml">


<link rel="icon" href="/./favicon.ico">

    

<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1278192097 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1278192097%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278192097'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s9.cnzz.com/z_stat.php%3Fid%3D1278192097%26online%3D2' type='text/javascript'%3E%3C/script%3E"));</script>

</div>




    

<script>
(function() {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    /./img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='xm'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://blog.eyes487.top">
                        eyes487的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa fa-home"></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/前端/"><i class="fa fa-html5"></i>
                                前端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa fa-clock-o"></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="理解浏览器和Node中的事件循环(EventLoop)">
            
            理解浏览器和Node中的事件循环(EventLoop)
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/前端/">前端</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/Js/">Js</a> <a class="tag-link" href="/tags/Node/">Node</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2019/10/20</span>
    </span>
    
    <!-- <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span> -->
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p>看过很多类似文章之后，想总结了一下关键点记录下来，方便之后回顾。<br>了解EventLoop可以用来分析一些异步次序的问题，同时还能了解一些浏览器和Node的内部机制。</p>
<h1 id="前言-为什么是事件循环"><a href="#前言-为什么是事件循环" class="headerlink" title="前言: 为什么是事件循环"></a>前言: 为什么是事件循环</h1><blockquote>
<p>网景公司在1994年发明了第一个浏览器，之前网速都是非常慢的，所以等服务器反应可能需要很久，假如一个场景，表单填写，填写完成之后，等很久浏览器反应之后发现表单填写时错误的，这样多试几次之后，可能人都是崩溃的，所以网景这个公司花了7天的时间，设计了javascript，用来帮助用户可以在浏览器端做一些基础的校验，来减少交互的过程。可以看出，js是创建出来为了辅助网景公司销售他们的浏览器。<br>根据标准中对时间循环的定义描述，我们可以发现事件循环本质上是<code>user agent</code>(如浏览器端)用于协调用户交互（鼠标、键盘)、脚本（如js）、渲染（如HTML DOM、css样式）、网络等行为的一个机制。与其说是js提供了事件循环，不如说是嵌入js的<code>user agent</code> 需要事件循环来与多种事件源交互。</p>
</blockquote>
<h1 id="1-浏览器中的EventLoop"><a href="#1-浏览器中的EventLoop" class="headerlink" title="1.浏览器中的EventLoop"></a>1.浏览器中的EventLoop</h1><h2 id="1-1-js引擎的事件循环机制"><a href="#1-1-js引擎的事件循环机制" class="headerlink" title="1.1 js引擎的事件循环机制"></a>1.1 js引擎的事件循环机制</h2><ul>
<li><p>js是一门<code>单线程</code>、<code>无阻塞</code>的脚本语言。</p>
</li>
<li><p>执行js文件的时候，会按照<code>从上到下</code>的顺序，把其中的同步代码加入<code>执行栈</code>中，然后按照<code>顺序</code>执行执行栈中的代码。</p>
</li>
<li><p>执行<code>异步</code>代码的时候，他不会立即返回结果，会将这个异步事件挂着，当异步事件返回结果的时候，就会把这个事件加入<code>事件队列</code></p>
</li>
<li><p>他不会立即执行，直到执行栈中的所有任务都<code>执行完毕</code>，主线程处于<code>闲置</code>状态的时候，主线程就会去查询<code>事件队列</code>是都有任务</p>
</li>
<li><p>有的话,就从中取出排在<code>第一位</code>的事件，把这个事件的<code>回调函数</code>加入执行栈，然后执行其中的代码</p>
</li>
<li><p>如此反复，就形成了无线的循环，这个过程就叫做 <code>事件循环</code></p>
</li>
</ul>
<h2 id="1-2-事件队列"><a href="#1-2-事件队列" class="headerlink" title="1.2 事件队列"></a>1.2 事件队列</h2><p>事件队列也分为 <strong>宏任务</strong>（<code>macrotask</code>) 和 <strong>微任务</strong>（<code>microtask</code>）</p>
<p><img src="http://fs.eyes487.top:9999/uploads/1573386573224-eventloop1.png" alt="浏览器中的 EventLoop" title="图1"></p>
<p>常见属于宏任务的有：</p>
<ul>
<li><code>script(整体代码)</code></li>
<li><code>setTimeout</code> / <code>setInterval</code></li>
<li>事件回调</li>
<li>网络请求等，<code>XHR</code> 回调</li>
<li><code>history.back</code></li>
</ul>
<p>常见属于微任务的有：</p>
<ul>
<li><code>Promise</code></li>
<li><code>MutaionObserver</code>，是H5的新特性</li>
<li><code>Object.observe</code>(废弃)</li>
</ul>
<p>在事件循环中，每进行一次循环操作称为tick</p>
<ul>
<li>在此次tick中最先进入的执行栈的任务(第一次是script代码)执行一次，执行完毕</li>
<li>在执行栈为空的时候，主线程就会查看微任务列表是否为空</li>
<li>存在微任务，就会不停地执行，直至微任务清空</li>
<li>执行UI render</li>
<li>下一次tick，执行任务队列排在第一的宏任务，执行完毕，可能会产生微任务</li>
<li>是否有微任务，执行直至清空队列</li>
<li>执行UI render</li>
<li>主线程重复执行上述步骤</li>
</ul>
<blockquote>
<p>浏览器完成一个宏任务，在下一个宏任务执行开始前，会对页面进行重新渲染。如果存在微任务，浏览器会清空微任务之后再重新渲染。</p>
</blockquote>
<p>下面这张图可以说明流程<br><img src="http://fs.eyes487.top:9999/uploads/1580464442587-eventloop.jpg" alt="浏览器中的 EventLoop" title="图2"></p>
<h2 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>正确的打印顺序是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>分析，第一步：</p>
<ul>
<li>先打印1 </li>
<li>setTimeout加入事件队列（宏任务)</li>
<li>接着打印 4，promise的返回的回调加入事件队列（微任务）</li>
<li>setTimeout加入事件队列（宏任务）</li>
<li>接着打印10</li>
</ul>
<p>第二步：</p>
<ul>
<li>微任务在宏任务之前执行，打印 5</li>
<li>此次微任务又产生了微任务，会在宏任务之前执行，接着打印 6</li>
<li>打印 7</li>
<li>把setTimeOut 加入事件队列(宏任务)</li>
</ul>
<p>第三步：</p>
<ul>
<li>此时，已经不存在微任务，按照顺序执行宏任务，打印2</li>
<li>执行时，又产生了一个微任务，只能先执行这个微任务，打印3</li>
<li>微任务执行完毕，按照顺序，执行宏任务，打印9</li>
<li>打印 8</li>
</ul>
<blockquote>
<p>所以，如果执行任务的时候不断的产生了微任务，那之后的宏任务就没办法执行了</p>
</blockquote>
<h1 id="2-Node中的EventLoop"><a href="#2-Node中的EventLoop" class="headerlink" title="2.Node中的EventLoop"></a>2.Node中的EventLoop</h1><p>Node的异步语法比浏览器更复杂，它可以和内核对话，所以它使用了<code>libuv</code>库来实现EventLoop，这个库负责各种回调函数的执行时间。</p>
<ul>
<li><strong>node中有一个注意的点</strong>：</li>
<li>在<code>node v11</code>以下，它的执行顺序是先清空宏任务队列，然后在清空微任务队列，这样保证所有队列都有相等机会执行，这和浏览器执行顺序不一样</li>
<li>但是，在<code>node v11</code>开始，就修复了这个问题，执行顺序就和浏览器一致了，先执行一个宏任务，就清空微任务队列</li>
</ul>
<h2 id="2-1-Node中提供了四个定时器"><a href="#2-1-Node中提供了四个定时器" class="headerlink" title="2.1 Node中提供了四个定时器"></a>2.1 Node中提供了四个定时器</h2><ul>
<li><code>setTimeout()</code></li>
<li><code>setInterval()</code></li>
<li><code>setImmediate()</code></li>
<li><code>process.nextTick()</code><br>上面两个语言标准，后两个是Node中独有的。<br>看看几个定时器在Node中的运行顺序:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))();</span><br><span class="line"></span><br><span class="line"><span class="comment">//node index.js</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>Node 规定，<code>process.nextTick</code>和<code>Promise</code>的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>的回调函数，追加在次轮循环,而本轮循环一定早于次轮循环执行。</p>
</blockquote>
<p>所有同步任务执行完之后就是异步任务，process.nextTick是异步任务中最早执行的，如果想要异步任务尽快执行，就使用process.nextTick。<br>而promise的回调函数会被添加于微任务队列，追加在process.nextTick之后，也存在于本轮循环，只有等本轮循环(当前队列)执行完之后，才会进入下一队列。</p>
<h2 id="2-2-事件循环的六个阶段"><a href="#2-2-事件循环的六个阶段" class="headerlink" title="2.2 事件循环的六个阶段"></a>2.2 事件循环的六个阶段</h2><p>事件循环会按照顺序，反复地执行。每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。</p>
<p><img src="http://fs.eyes487.top:9999/uploads/1573386585444-eventloop2.jpg" alt="Node中的 EventLoop" title="图3"></p>
<h3 id="2-2-1-timers"><a href="#2-2-1-timers" class="headerlink" title="2.2.1 timers"></a>2.2.1 timers</h3><p>这个是定时器阶段，处理<code>setTimeout()</code>和<code>setInterval()</code>的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。</p>
<h3 id="2-2-2-I-O-callbacks"><a href="#2-2-2-I-O-callbacks" class="headerlink" title="2.2.2 I/O callbacks"></a>2.2.2 I/O callbacks</h3><p>除了以下操作的回调函数，其他回调函数都在这个阶段执行</p>
<ul>
<li>setTimeout()和setInterval()的回调函数</li>
<li>setImmediate()的回调函数</li>
<li>用于关闭请求的回调函数，比如socket.on(‘close’, …)</li>
</ul>
<blockquote>
<p>根据libuv的文档，一些应该在上轮循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。</p>
</blockquote>
<h3 id="2-2-3-idle-prepare"><a href="#2-2-3-idle-prepare" class="headerlink" title="2.2.3 idle, prepare"></a>2.2.3 idle, prepare</h3><p>该阶段只供 <code>libuv</code> 内部调用，这里可以忽略。</p>
<h3 id="2-2-4-Poll"><a href="#2-2-4-Poll" class="headerlink" title="2.2.4 Poll"></a>2.2.4 Poll</h3><p>这个阶段是轮询时间，用于等待还未返回的 <code>I/O</code>事件，比如服务器的回应、用户移动鼠标等等。<br>这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</p>
<h3 id="2-2-5-check"><a href="#2-2-5-check" class="headerlink" title="2.2.5 check"></a>2.2.5 check</h3><p>该阶段执行<code>setImmediate()</code>的回调函数。</p>
<h3 id="2-2-6-close-callbacks"><a href="#2-2-6-close-callbacks" class="headerlink" title="2.2.6 close callbacks"></a>2.2.6 close callbacks</h3><p>该阶段执行关闭请求的回调函数，比如<code>socket.on(&#39;close&#39;, ...)</code>。</p>
<h2 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h2><p>来自官方文档的一个示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务一：100ms 后执行的定时器</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务二：文件读取后，有一个 200ms 的回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'test.js'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 什么也不做</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>分析：第一轮</p>
<ul>
<li>没有到期的定时器</li>
<li>也没有刻意执行的 I/O 回调函数</li>
<li>内核读取文件</li>
<li>Poll阶段，等待内核读取文件的结果，不会操作100ms，在定时器到期之前就会得到结果</li>
</ul>
<p>第二轮</p>
<ul>
<li>没有到期的定时器</li>
<li>有刻意执行的回调函数，进入<code>I/O callbacks</code>阶段，这个回调函数需要200ms，在执行到一半的时候，100ms定时器到期，但是必须等到这个回调函数执行完，才会离开这个阶段</li>
</ul>
<p>第三轮</p>
<ul>
<li>有了到期的定时器，所以会在timers阶段执行定时器，输出结果大概200多毫秒</li>
</ul>
<h2 id="2-4-setTimeout-和-setImmediate"><a href="#2-4-setTimeout-和-setImmediate" class="headerlink" title="2.4 setTimeout 和 setImmediate"></a>2.4 setTimeout 和 setImmediate</h2><p>由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果不确定</span></span><br><span class="line"><span class="comment">//1  2  或者  2  1</span></span><br></pre></td></tr></table></figure>

<p>因为</p>
<blockquote>
<p>setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。</p>
</blockquote>
<p>实际执行，进入事件循环，有可能到了1毫秒，有可能没有，这取决于系统当时的情况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。</p>
<p>但是，下面代码一定是2   1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'test.js'</span>, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。</p>
<p>————-如果以上内容有不对的地方，还请大家指正————</p>
<p>Node中的事件循环参考<br><a href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html" target="_blank" rel="noopener">《Node 定时器详解》</a><br><a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882" target="_blank" rel="noopener">《不要混淆nodejs和浏览器中的event loop》</a></p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://blog.eyes487.top" target="_blank">eyes487的博客</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2019/10/21/problem-of-react-native.html" class="pre-post btn btn-default" title='React Native 开发中所遇到的问题'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            React Native 开发中所遇到的问题</span>
    </a>
    
    
    <a href="/2019/10/13/dom-diff-algorithnm.html" class="next-post btn btn-default" title='手写DOM-Diff算法'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            手写DOM-Diff算法</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMzA1MS85NjEz">
    <script type="text/javascript">
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
    </script>
</div>

</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言-为什么是事件循环"><span class="toc-text">前言: 为什么是事件循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-浏览器中的EventLoop"><span class="toc-text">1.浏览器中的EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-js引擎的事件循环机制"><span class="toc-text">1.1 js引擎的事件循环机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-事件队列"><span class="toc-text">1.2 事件队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-示例"><span class="toc-text">1.3 示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Node中的EventLoop"><span class="toc-text">2.Node中的EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Node中提供了四个定时器"><span class="toc-text">2.1 Node中提供了四个定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-事件循环的六个阶段"><span class="toc-text">2.2 事件循环的六个阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-timers"><span class="toc-text">2.2.1 timers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-I-O-callbacks"><span class="toc-text">2.2.2 I/O callbacks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-idle-prepare"><span class="toc-text">2.2.3 idle, prepare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-Poll"><span class="toc-text">2.2.4 Poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-check"><span class="toc-text">2.2.5 check</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-close-callbacks"><span class="toc-text">2.2.6 close callbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-示例"><span class="toc-text">2.3 示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-setTimeout-和-setImmediate"><span class="toc-text">2.4 setTimeout 和 setImmediate</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2019
                </span> |
                <span>
                   哈哈哈
                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/line.js?rev=@@hash"></script>
<script src="/js/bubble.js?rev=@@hash"></script>
<script src="/js/shape.js?rev=@@hash"></script>
<script src="/js/app.js?rev=@@hash"></script>
</body>
</html>