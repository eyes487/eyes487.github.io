---
title: 浏览器中的事件循环(EventLoop)
categories: 前端
tag: ['Js']
date: 2019-10-20
---

看过很多类似文章之后，想总结了一下关键点记录下来，方便之后回顾


## 1.js引擎的事件循环机制

 * js是一门`单线程`、`无阻塞`的脚本语言。

 * 执行js文件的时候，会按照`从上到下`的顺序，把其中的同步代码加入`执行栈`中，然后按照`顺序`执行执行栈中的代码。

 * 执行`异步`代码的时候，他不会立即返回结果，会将这个异步事件挂着，当异步事件返回结果的时候，就会把这个事件加入`事件队列`

 * 他不会立即执行，直到执行栈中的所有任务都`执行完毕`，主线程处于`闲置`状态的时候，主线程就会去查询`事件队列`是都有任务

 * 有的话,就从中取出排在`第一位`的事件，把这个事件的`回调函数`加入执行栈，然后执行其中的代码

 * 如此反复，就形成了无线的循环，这个过程就叫做 `事件循环`




## 2.事件队列

事件队列也分为 **宏任务**（`macrotask`) 和 **微任务**（`microtask`）

常见属于宏任务的有：
* `setTimeout` / `setInterval`
* 事件回调
* `XHR` 回调
* `history.back`

常见属于微任务的有：
* `new Promise`
* `new MutaionObserver()`
* `Object.observe`

> * 在执行栈为空的时候，主线程首先会查看微任务列表是否为空
> * 先执行微任务，执行完毕，在执行宏任务
> * 同一次事件循环，微任务总是比宏任务先执行。


>运行宏任务的时候，可能又会产生微任务，在执行完毕这次宏任务，又会查询是否有微任务需要执行。

## 3.实例

```js
console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
  
  Promise.resolve().then(() => {
    console.log(6)
  }).then(() => {
    console.log(7)
    
    setTimeout(() => {
      console.log(8)
    }, 0);
  });
})

setTimeout(() => {
  console.log(9);
})

console.log(10);
```

正确的打印顺序是:
```js
1
4
10
5
6
7
2
3
9
8
```


分析，第一步：
* 先打印1 
* setTimeout加入事件队列（宏任务)
* 接着打印 4，promise的返回的回调加入事件队列（微任务）
* setTimeout加入事件队列（宏任务）
* 接着打印10

第二步：
* 微任务在宏任务之前执行，打印 5
* 此次微任务又产生了微任务，会在宏任务之前执行，接着打印 6
* 打印 7
* 把setTimeOut 加入事件队列(宏任务)

第三步：
* 此时，已经不存在微任务，按照顺序执行宏任务，打印2
* 执行时，又产生了一个微任务，只能先执行这个微任务，打印3
* 微任务执行完毕，按照顺序，执行宏任务，打印9
* 打印 8

> 所以，如果执行任务的时候不断的产生了微任务，那之后的宏任务就没办法执行了

------Node中的EventLoop了解话不是很深，下次再补上-------