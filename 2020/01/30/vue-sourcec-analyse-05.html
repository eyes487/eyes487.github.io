<!DOCTYPE HTML>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="eyes487的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <meta name="google-site-verification" content="kh2qynWK0TEziuoSJmSB1lNTaVoVXykqpgCSyD1FtWA">
    <link rel="dns-prefetch" href="http://blog.eyes487.top">
    <!--SEO-->

<meta name="keywords" content="虚拟DOM,Vue,源码">


<meta name="description" content="在Vue2中，数据响应式和虚拟DOM是分不开，它们是Vue的核心。Vue2中是一个组件一个Watcher实例，假如数据变化了，只能通知组件更新，这时就需要用到虚拟DOM和diff算法对比得出差异...">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>
    
    Vue源码解析（五）：虚拟dom和diff算法 |
    
    eyes487的博客
</title>

<link rel="alternate" href="/atom.xml" title="eyes487的博客" type="application/atom+xml">


<link rel="icon" href="/./favicon.ico">

    

<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1278192097 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1278192097%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1278192097'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s9.cnzz.com/z_stat.php%3Fid%3D1278192097%26online%3D2' type='text/javascript'%3E%3C/script%3E"));</script>

</div>




    

<script>
(function() {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    /./img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='xm'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://blog.eyes487.top">
                        eyes487的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa fa-home"></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/前端/"><i class="fa fa-html5"></i>
                                前端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa fa-clock-o"></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Vue源码解析（五）：虚拟dom和diff算法">
            
            Vue源码解析（五）：虚拟dom和diff算法
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/前端/">前端</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/Vue/">Vue</a> <a class="tag-link" href="/tags/源码/">源码</a> <a class="tag-link" href="/tags/虚拟DOM/">虚拟DOM</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2020/01/30</span>
    </span>
    
    <!-- <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span> -->
    
    
</div>
        
        
        <p class="fa fa-exclamation-triangle warning">
            本文于<strong>
                436</strong>
            天之前发表，文中内容可能已经过时。
        </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>在Vue2中，数据响应式和虚拟DOM是分不开，它们是Vue的核心。Vue2中是一个组件一个Watcher实例，假如数据变化了，只能通知组件更新，这时就需要用到虚拟DOM和diff算法对比得出差异更新真实DOM了。</p>
<p>Vue版本: 2.6.11</p>
<h2 id="1-虚拟DOM"><a href="#1-虚拟DOM" class="headerlink" title="1. 虚拟DOM"></a>1. 虚拟DOM</h2><p>虚拟DOM(Virtual DOM)是对DOM的js抽象表示，他们是<strong>js对象</strong>，能描述<strong>DOM结构和关系</strong>，应用的各种状态变化会作用于虚拟DOM，最终映射到真实DOM上。因为是纯粹的js对象，所以操作起来就很高效。页面渲染的时候生成vdom，数据更新会生成一个新的vdom，<strong>新的vdom</strong>和<strong>老的vdom</strong>进行比较，这个过程称为<strong>diff</strong>算法，得出差异，应用在真实dom上。</p>
<p>Vue的diff算法是基于<code>snabbdom</code>算法所做的修改，感兴趣的朋友可以自己去查看。</p>
<p>下面从源码中去分析vue中的vdom是如何工作的。</p>
<h2 id="2-渲染和更新流程"><a href="#2-渲染和更新流程" class="headerlink" title="2. 渲染和更新流程"></a>2. 渲染和更新流程</h2><p>首先，我们要找到，vm实例挂载的$mount会调用<code>mountComponent函数</code>(第二篇文章有说过)，看看这个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//   ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//用户$mount时，定义updateComponent</span></span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//我们将其设置为观察者构造函数中的vm._watcher</span></span><br><span class="line">  <span class="comment">//因为观察者的初始补丁可能会调用$ forceUpdate（例如，在child内部</span></span><br><span class="line">  <span class="comment">//组件的挂接钩），它依赖于已定义的vm._watcher </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户在<code>$mount</code>时，定义<code>updateComponent</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面 <code>new Watcher</code>把刚才定义的更新函数传进去了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br></pre></td></tr></table></figure>

<p>如果<code>watcher</code>执行<code>run</code>方法，就会调用传入的回调，也就是<code>updateComponent</code><br>而<code>updatemount</code>中需要执行<code>_render</code>方法,返回vdom，其中也就是给vdom额外的加了一些vue的属性，把返回的<code>vdom</code>作为<code>_update</code>的第一个参数，然后执行<code>_update</code>方法</p>
<p>那看看<code>_update</code>方法是如何工作的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/core/instance/lifecycle.js</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// 初始渲染 </span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在这里面，我们发现<code>vm.__patch__</code>方法，上面是初始化渲染，只要传入宿主元素和vdom就行，下面是更新，需要传入老的vdom和新的vdom。看看<code>patch</code>都做了什么,在<code>src/core/vdom/patch.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否有新的虚拟dom， 没有就删除</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否有老的节点 1.初始化的时候，有传入$el, 2.更新，传入oldVnode</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//是否是真正的dom</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        <span class="comment">//更新的时候，真正的diff算法</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//真实dom，就是初始化渲染</span></span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">// 创建一个空节点并替换它</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replacing existing element</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm <span class="comment">//当前宿主元素</span></span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm) <span class="comment">//即body，之后把新创建的真实dom追加进body，然后在删除之前的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// create new node</span></span><br><span class="line">        <span class="comment">//根据虚拟dom创建真实dom</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">          <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">          <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// #6513</span></span><br><span class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">              <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">              <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先会做一系列的判断，老节点和新节点的判断，更新操作,会执行<code>patchVnode</code>方法，初始化渲染，会根据虚拟dom生成真实dom追加在宿主元素的父节点中，然后在删除旧的节点。</p>
<p>下面看个例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>虚拟dom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;obj.foo&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#demo'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        obj:&#123;</span><br><span class="line">            foo:<span class="string">'hello world'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行结果<br><img src="https://www.eyes487.top/fs/uploads/1580824895607-vdom.gif" alt="初始化渲染" title="图1"></p>
<h2 id="3-diff算法"><a href="#3-diff算法" class="headerlink" title="3. diff算法"></a>3. diff算法</h2><p><img src="https://www.eyes487.top/fs/uploads/1580889869180-compare.png" alt="同级比较" title="图2"></p>
<p>这是一张很经典的图，出自<strong>《React’s diff algorithm》</strong>，Vue的diff算法也同样，即仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。那同级vnode diff的细节又是怎样的呢？</p>
<h3 id="3-1-sameVnode"><a href="#3-1-sameVnode" class="headerlink" title="3.1 sameVnode"></a>3.1 sameVnode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src\core\vdom\patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; ( <span class="comment">// key值</span></span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;  <span class="comment">// 标签名</span></span><br><span class="line">        a.isComment === b.isComment &amp;&amp;  <span class="comment">// 是否为注释节点</span></span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;  <span class="comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span></span><br><span class="line">        sameInputType(a, b)   <span class="comment">// 当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行<code>patchVnode</code>之前会执行<code>sameVnode</code>判断，新老节点是否是否是同类型节点，值得进行<code>patchVnode</code></p>
<h3 id="3-2-patchVnode"><a href="#3-2-patchVnode" class="headerlink" title="3.2 patchVnode"></a>3.2 patchVnode</h3><p>先总结一下其中的规则，比较两个vnode，包括三种类型操作：<strong>属性更新</strong>，<strong>文本更新</strong>，<strong>子节点更新</strong><br>具体规则如下：</p>
<ul>
<li>新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren</li>
<li>如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点</li>
<li>当新节点没有子节点而老节点有子节点的时候，则先移除该节点的所有子节点</li>
<li>当新老节点都无子节点的时候，只是文本替换</li>
</ul>
<p>那我们先看看<code>patchVnode</code>都做了什么<br>里面会有优化操作，比如<code>isAsyncPlaceholder</code>,<code>isStatic</code>,是否是占位符，静态节点，就不用了做<code>diff</code>了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src\core\vdom\patch.js</span></span><br><span class="line"><span class="comment">//判断是否是元素</span></span><br><span class="line"><span class="keyword">if</span> (isUndef(vnode.text)) &#123; <span class="comment">//没有文本就是元素</span></span><br><span class="line">  <span class="comment">//双方都有孩子</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">    <span class="comment">//比孩子，重排</span></span><br><span class="line">    <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">    <span class="comment">//新节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空老节点文本</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    <span class="comment">// 创建孩子并追加</span></span><br><span class="line">    addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">    <span class="comment">//老节点有孩子，直接删除即可</span></span><br><span class="line">    removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123; </span><br><span class="line">    <span class="comment">//老节点存在文本，清空</span></span><br><span class="line">    nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">  <span class="comment">//双方都是文本节点，更新</span></span><br><span class="line">  nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面最主要的就是重排算法<code>updateChildren</code>，下面看看里面究竟是如何工作的</p>
<h3 id="3-3-updateChildren"><a href="#3-3-updateChildren" class="headerlink" title="3.3 updateChildren"></a>3.3 updateChildren</h3><p>推荐<a href="https://blog.csdn.net/m6i37jk/article/details/78140159" target="_blank" rel="noopener">一篇文章</a>，用例子讲解的很详细，</p>
<p>比较两棵树最直接的方法就是双循环了，Vue中针对web场景做了特殊的<strong>优化方式</strong>。很多情况下我们都是在<strong>前面</strong>或者<strong>后面</strong>去追加节点，或者就是<strong>升序</strong>或者<strong>降序</strong>排列，那大概率的就是前面和后面的比较。有一个高效的方式，就是给不同节点设置<code>key</code>，就可以快速找到节点，进行判断是不是相同节点。</p>
<p><img src="https://www.eyes487.top/fs/uploads/1580893492529-vdom-diff1.png" alt="vdom-diff1" title="图3"></p>
<p>Vue中就是在新老两组vdom节点的左右两头设置了两对指针，在遍历的过程中，这几个指针都会向中间靠拢，当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。处理过的节点Vue会在oldVdom和newVdom中同时将它标记为已处理。</p>
<p><strong>下面看遍历规则</strong></p>
<p><strong>优先处理</strong>的情况</p>
<ul>
<li>头部的同类型节点、尾部的同类型节点, 这类节点更新前后位置没有发生变化，所以不用移动它们对应的DOM</li>
<li>头尾/尾头的同类型节点, 这类节点位置很明确，不需要再花心思查找，直接移动DOM就好</li>
</ul>
<p><strong>原地复用</strong>是Vue会尽可能的复用节点，不发生dom的移动。如果两个节点时同类节点(比如：div),那么Vue会直接复用DOM，这样的好处是不需要移动,但是也会产生一些问题。</p>
<p><strong>整个过程是逐步找到更新前后vdom的差异，然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM（React则是将更新放入队列后集中处理），朋友们会问这样做性能很差吧？实际上现代浏览器对这样的DOM操作做了优化，并无差别。</strong></p>
<p>先看看代码吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src\core\vdom\patch.js</span></span><br><span class="line"><span class="comment">//循环条件：开始索引不能大于结束索引</span></span><br><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    newEndVnode = newCh[--newEndIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">    <span class="comment">//老的开始和新的结束节点相同，除了打补丁之外，向后移动</span></span><br><span class="line">    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">    newEndVnode = newCh[--newEndIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//4中猜想之后没有找到相同的，不得不开始循环查找</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    idxInOld = isDef(newStartVnode.key)</span><br><span class="line">      ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">      : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">      <span class="comment">//没找到则创建新元素</span></span><br><span class="line">      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//找到除了打补丁，还要移动到对首</span></span><br><span class="line">      vnodeToMove = oldCh[idxInOld]</span><br><span class="line">      <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整理工作，必定有数组还剩下的元素未处理</span></span><br><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，当 <strong>oldStartVnode</strong> 和 <strong>newStartVnode</strong> 或者 <strong>oldEndVnode</strong>和<strong>newEndVnode</strong> 满足同类节点，直接将该<br>VNode节点进行patchVnode即可，深层次比较，节点相同的两个指针向中间移动一个，不需再遍历就完成了一次循环。如下图，<br><img src="https://www.eyes487.top/fs/uploads/1580895808862-vdom-diff2.png" alt="vdom-diff2" title="图4"></p>
<p>如果<strong>oldStartVnode</strong>与<strong>newEndVnode</strong>满足同类节点。说明<strong>oldStartVnode</strong>已经跑到了<strong>oldEndVnode</strong><br>后面去了，进行patchVnode的同时还需要将真实DOM节点移动到<strong>oldEndVnode</strong>的后面。这两个指针向中间移动一格。<br><img src="https://www.eyes487.top/fs/uploads/1580896064990-vdom-diff3.png" alt="vdom-diff3" title="图5"></p>
<p>如果<strong>oldEndVnode</strong>与<strong>newStartVnode</strong>满足同类节点，说明<strong>oldEndVnode</strong>跑到了<strong>oldStartVnode</strong>的前<br>面，进行patchVnode的同时要将<strong>oldEndVnode</strong>对应DOM移动到<strong>oldStartVnode</strong>对应DOM的前面。这两个指针向中间移动一格。<br><img src="https://www.eyes487.top/fs/uploads/1580896064997-vdom-diff4.png" alt="vdom-diff4" title="图6"></p>
<p>如果以上情况均不符合，则在old VNode中找与<strong>newStartVnode</strong>满足同类节点的vnodeToMove，如果找到了，就执行patchVnode，同时将vnodeToMove对应DOM移动到<strong>oldStartVnode</strong>对应的DOM的前面，<strong>newStartVnode</strong>向后移一格，但是在oldVnode中该节点处没有指针，所以就不能移动，只能该老节点标记一下说明它已经处理过了，设置为undefined<br><img src="https://www.eyes487.top/fs/uploads/1580896065011-vdom-diff5.png" alt="vdom-diff5" title="图7"></p>
<p>当然也有可能<strong>newStartVnode</strong>在old VNode节点中找不到一致的key，或者是即便key相同却不是同类节点，这个时候会调用createElm创建一个新的DOM节点。<br><img src="https://www.eyes487.top/fs/uploads/1580896456382-vdom-diff6.png" alt="vdom-diff6" title="图8"></p>
<p>至此循环结束，但是我们还需要处理剩下的节点。</p>
<p>当结束时oldStartIdx &gt; oldEndIdx，这个时候旧的VNode节点已经遍历完了，但是新的节点还没有。说明了新的VNode节点实际上比老VNode节点多，需要将剩下的VNode对应的DOM插入到真实DOM中，此时调用addVnodes（批量调用createElm接口）。<br><img src="https://www.eyes487.top/fs/uploads/1580896456391-vdom-diff7.png" alt="vdom-diff7" title="图9"></p>
<p>但是，当结束时<strong>newStartIdx</strong> &gt; <strong>newEndIdx</strong>时，说明新的VNode节点已经遍历完了，但是老的节点还有剩余，需要从文档中的节点删除。<br><img src="https://www.eyes487.top/fs/uploads/1580896456394-vdom-diff8.png" alt="vdom-diff8" title="图10"></p>
<p>至此，整个diff算法就结束了。</p>
<p>————-如果以上内容有不对的地方，还请大家指正————</p>
<p>参考链接：<br><a href="https://blog.csdn.net/m6i37jk/article/details/78140159" target="_blank" rel="noopener">深入Vue2.x的虚拟DOM diff原理</a><br><a href="https://blog.csdn.net/kameleon2013/article/details/89218685" target="_blank" rel="noopener">Vue 虚拟DOM和Diff算法</a></p>
<p>目录<br><a href="https://blog.eyes487.top/2020/01/26/vue-sourcec-analyse-01.html">《Vue源码解析（一）：如何解读源码》</a><br><a href="https://blog.eyes487.top/2020/01/27/vue-sourcec-analyse-02.html">《Vue源码解析（二）：new Vue() 初始化流程》</a><br><a href="https://blog.eyes487.top/2020/01/28/vue-sourcec-analyse-03.html">《Vue源码解析（三）：数据响应式》</a><br><a href="https://blog.eyes487.top/2020/01/29/vue-sourcec-analyse-04.html">《Vue源码解析（四）：Vue批量异步更新策略》</a><br>《Vue源码解析（五）：虚拟dom和diff算法》</p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://blog.eyes487.top" target="_blank">eyes487的博客</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2020/02/26/achieve-redux.html" class="pre-post btn btn-default" title='redux 简单实现'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            redux 简单实现</span>
    </a>
    
    
    <a href="/2020/01/29/vue-sourcec-analyse-04.html" class="next-post btn btn-default" title='Vue源码解析（四）：Vue批量异步更新策略'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            Vue源码解析（四）：Vue批量异步更新策略</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMzA1MS85NjEz">
    <script type="text/javascript">
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
    </script>
</div>

</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-虚拟DOM"><span class="toc-text">1. 虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-渲染和更新流程"><span class="toc-text">2. 渲染和更新流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-diff算法"><span class="toc-text">3. diff算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-sameVnode"><span class="toc-text">3.1 sameVnode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-patchVnode"><span class="toc-text">3.2 patchVnode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-updateChildren"><span class="toc-text">3.3 updateChildren</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2019
                </span> |
                <span>
                   哈哈哈
                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/line.js?rev=@@hash"></script>
<script src="/js/bubble.js?rev=@@hash"></script>
<script src="/js/shape.js?rev=@@hash"></script>
<script src="/js/app.js?rev=@@hash"></script>
</body>
</html>